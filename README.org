* Artifact for the ITP'21 submission: "Compositional Compiler Correctness for HELIX" 

  The supplementary material submitted with our paper is constituted of two frozen branches:
  - The branch `itp21` of the HELIX project:  https://github.com/vzaliva/helix/tree/itp21/
  - The branch `itp21` of the Vellvm project: https://github.com/vellvm/vellvm/tree/itp21
  Installation instructions can be found below.

* Connection with the results described in the paper

** Helix side
  
   The repository https://github.com/vzaliva/helix/tree/itp21/ contains the HELIX development over-viewed in Section 2. Here the following may be found:
   
   - the abstract syntax of DHCOL, of which FHCOL is a specialization, described in Section 3: [[./coq/DSigmaHCOL/DSigmaHCOL.v][DSigmaHCOL]]
   - the big-step interpreter, also described in Section 3: [[./coq/DSigmaHCOL/DSigmaHCOLEval.v][DSigmaHCOLEval]]
   - the itree-based denotation, described in Section 5: [[./coq/DSigmaHCOL/DSigmaHCOLITree.v][DSigmaHCOLITree]] 
   - the proof of correctness of this new semantics, stated in Section 5: [[./coq/LLVMGen/EvalDenoteEquiv.v][EvalDenoteEquiv]]
   - the compilation pass from FHCOL down to LLVM IR, described through Section 4: [[./coq/LLVMGen/Compiler.v][Compiler]]
   - all the other files contained in [[./coq/LLVMGen/][LLVMGen]] are part of the proof of correctness for the compilation of operators,
     stated in Section 5.
     
     The state invariant sketched in Section 7 can be found in [[./coq/LLVMGen/Correctness_Invariants.v][Correctness_Invariants]].
     
     The result itself is stated in [[./coq/LLVMGen/Correctness_GenIR.v][Correctness_GenIR]].
     
     *Note on admits*:
     
     This file contains three admits. These correspond to three operators that we have not yet proved (and have not presented in the paper).
     
     We emphasize that these operators have a similar structure to the cases of IMap and Power that we have proved:
     they use "genWhileLoop" to iterate some operation over a vector.
     As such, we are confident that while these proofs will require some non-trivial effort, they will not require
     any new meta-theory nor significant invariant, and hence will not be an obstacle. We intend to tackle them
     in the upcoming weeks.

     The [[./coq/LLVMGen/Correctness_IMap.v][Correctness_IMap]] file contains one admit: [commut_gen']. This technical lemma is a variant of
     a series of others that we have proved to commute pure computations represented as itrees under the right hypotheses.
     We use it to prove that it is benign for the compiler to inverse the order of iteration when compiling down the IMap operator.
     We unfortunately realized late that the meta-theoretical lemma [commut_gen] that we had proved ahead of time was slightly too weak
     for our purpose, and hence admitted temporarily this stronger version. 
   
** Vellvm side

   The repository https://github.com/vellvm/vellvm/tree/itp21 as a whole
   contains the Vellvm development. In here can be found:

   - the abstract syntax of the language, omitted from the paper: [[./src/coq/Syntax/LLVMAst.v][LLVMAst.v]]
   - the semantics, the focus of another paper under submission and cited as such
     in the present submission, can be found primarily within
     the folders [[./src/coq/Semantics][Semantics]] and [[./src/coq/Handlers][Handlers]] 
   - the new extended meta-theory, described in Section 6, can be found in the folder [[./src/coq/Theory][Theory]]
   - the symbolic interpreter, described in Section 6, is defined in [[./src/coq/Theory/SymbolicInterpreter.v][SymbolicInterpreter]].
     We fine-tune it on the Helix side in the Prelude to enforce it to run on the right hand-side of
     refinement proofs, and to pair it with the shallow symbolic interpreter for the FHCOL denotation.
   - although as mentioned in Section 6 we work with the relation program logic at a shallow level in
     the current proof for HELIX, we have drafted a more formal take on it in [[./src/coq/Utils/RelLog.v][RelLog]]
   - we have not found the space to detail it in the paper, but the theoretical tools used to
     express the well-definedness of the source semantics in an itree-world is developed in [[./src/coq/Utils/NoFailure.v][NoFailure]] 
   - we have not found the space to detail it in the paper, but the [tfor] itree combinator we
     introduce to help reason generically about [genWhileLoop] is defined in [[./src/coq/Utils/TFor.v][TFor]]

     **Note on admits**: The Vellvm development contains three admits at the present.
     
     They are all three minor technicalities of the memory model, in [MemoryTheory](./src/coq/Handlers/MemoryTheory.v).
     
     One expresses the behavior of the successive deserialization of the serialization of a dynamic value: we have proved most cases,
     but it requires some tedious arithmetic at each numerical types, and lacked a few cycles to complete it.
     
     One relates to a fringe case w.r.t. what happens when one tries to read a data of size 0 from memory.
     
     The last one is about the size of values read in memory, and rises a slight issue in the fringe case mentioned above.
     
     None of them is related in any fashion to the heart of the proof that we present in this paper. We naturally intend to fix
     them as soon as possible nonetheless.


* HELIX

[[https://travis-ci.com/vzaliva/helix][https://travis-ci.com/vzaliva/helix.svg?token=x87izvm44MdTPLHzuxzF&branch=master]]

The HELIX project allows for the synthesis of high-performance
implementations of numerical algorithms by providing a certified
compiler for a formally-specified DSL. HELIX is based upon the existing 
[[http://spiral.net/][SPIRAL]] system, but the correctness of HELIX is formally verified
using the Coq proof assistant. It formally defines a series of
domain-specific languages starting with HCOL, which represents a
computation data flow. HELIX works by transforming the original
program through a series of intermediate languages, culminating in
LLVM IR.

- HELIX focuses on automatic translation a class of mathematical.
  expressions to code.
- It works by revealing implicit iteration constructs and re-shaping
  them to match target platform parallelizm and vectorization
  capabilities.
- HELIX is rigorously defined and formally verified.
- HELIX is implemented in Coq proof assistant.
- It supports non-linear operators.
- Presently, HELIX uses SPIRAL as an optimization oracle, but it
  certifies its findings.
- LLVM is used machine code generation backend.
- Main application: Cyber-physical systems.

** Example

   An application of HELIX to a real-life situation of high-assurance
   vehicle control [[http://spiral.ece.cmu.edu:8080/pub-spiral/abstract.jsp?id=281][(paper)]] using a dynamic window vehicle control
   approach [[https://doi.org/10.1109/100.580977][(paper)â€‹]] is shown below:

   [[doc/bigpicture.png]]

** Dependencies

   - [[https://coq.inria.fr/][Coq]]
   - [[http://color.inria.fr/][CoLoR]]
   - [[https://github.com/coq-ext-lib/coq-ext-lib][ExtLib]]
   - [[https://github.com/math-classes/math-classes][math-classes]]
   - [[https://github.com/MetaCoq/metacoq][Template Coq]]
   - [[http://flocq.gforge.inria.fr/][Flocq]]
   - [[https://github.com/vellvm/vellvm][Vellvm]] (requires ~coq-ceres~, ~coq-ext-lib~, ~coq-paco~, and ~coq-flocq~) /(manual installation instructions below)/
   - [[https://opensource.janestreet.com/core/][Jane Street Core]]
   - coq-libhyps
   - [[https://github.com/Karmaki/coq-dpdgraph][coq-dpdgraph]] /(optional)/

 To install all required dependenceis:

#+BEGIN_SRC sh
     opam repo add coq-released https://coq.inria.fr/opam/released
     opam pin add coq 8.12.2
     make -j 4 install-deps
#+END_SRC

To install *optional* dependencies:

#+BEGIN_SRC sh
     opam install coq-dpdgraph
#+END_SRC

** Bulding and Running 
*** Install VELLVM dependency:

    You need to manually check out the /itp21/ branch of VELLVM, compile,
    and symlink it as follows:

#+BEGIN_SRC sh
     ln -s path_to_vellvm_checkout/vellvm helix/lib
     ln -s path_to_vellvm_checkout/vellvm/src/ml/libvellvm helix/ml
#+END_SRC

*** Build:
    
#+BEGIN_SRC sh
     make
#+END_SRC
    
*** Run unit tests:

#+BEGIN_SRC sh
     make test
#+END_SRC

** Papers
    - [[http://www.crocodile.org/lord/vzaliva-VSTTE20.pdf][Verified Translation Between Purely Functional and Imperative Domain Specific Languages in HELIX (VSTTE 20)]]
    - [[http://www.crocodile.org/lord/vzaliva-CoqPL19.pdf][Reification of shallow-embedded DSLs in Coq with automated verification (CoqPL 2019)]]
    - [[http://www.crocodile.org/lord/vzaliva-fhpc2018.pdf][HELIX: A Case Study of a Formal Verification of High Performance Program Generation (FHPC 2018)]]
    - [[http://www.crocodile.org/lord/Formal_Verification_of_HCOL_Rewriting_FMCAD15.pdf][Formal Verification of HCOL Rewriting (FMCAD 2015)]]
** Contact

   [[mailto:vzaliva@cmu.edu][Vadim Zaliva]]

