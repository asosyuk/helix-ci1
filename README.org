* Artifact for the ITP'21 submission titled: "Compositional Compiler Correctness for HELIX" 

  The supplementary material submitted with our paper is constituted of two frozen branches:
  - The branch `itp21` of the HELIX project:  https://github.com/vzaliva/helix/tree/itp21/
  - The branch `itp21` of the Vellvm project: https://github.com/vellvm/vellvm/tree/itp21
  Installation instructions can be found below.

* Connection with the results described in the paper

** Helix side
  
   The repository https://github.com/vzaliva/helix/tree/itp21/ as a whole
   contains the HELIX development over-viewed in Section 2.
   More precisely, can be found:
   - the abstract syntax of DHCOL, of which FHCOL is a specialization, described in Section 3: [[./coq/DSigmaHCOL/DSigmaHCOL.v][DSigmaHCOL]] 
   - the big-step interpreter, also described in Section 3: [[./coq/DSigmaHCOL/DSigmaHCOLEval.v
Le check on y_size bounds
][DSigmaHCOLEval]] 
   - the itree-based denotation, described in Section 5: [[./coq/DSigmaHCOL/DSigmaHCOLITree.v][DSigmaHCOLITree]] 
   - the proof of correctness of this new semantics, stated in Section 5: [[./coq/LLVMGen/EvalDenoteEquiv.v][EvalDenoteEquiv]]
   - the compilation pass from FHCOL down to LLVM IR, described through Section 4: [[./coq/LLVMGen/Compiler.v][Compiler]]
   - all the other files contained in [[./coq/LLVMGen/][LLVMGen]] are part of the proof of correctness for the compilation of operators,
     stated in Section 5.
     The state invariant sketched in Section 7 can be found in [[./coq/LLVMGen/Correctness_Invariants.v][Correctness_Invariants]].
     The result itself is stated in [[./coq/LLVMGen/Correctness_GenIR.v][Correctness_GenIR]].
     *Note on admits*: This file contains three admits. These correspond to three operators that we have not yet proved.
     We emphasize that these operators have a similar structure to the cases of IMap and Power that we have proved:
     then use "genWhileLoop" to iterate some operation over a vector.
     As such, we are confident to state that while requiring some non-trivial effort, these proofs will not require
     any new meta-theory nor significant invariant, and hence will not be an obstacle. We intent to tackle them
     in the upcoming weeks.

   
** Vellvm side

   The repository https://github.com/vellvm/vellvm/tree/itp21 as a whole
   contains the Vellvm development. 
   More precisely, can be found:
   - the abstract syntax of the language, omitted from the paper: [[./src/coq/Syntax/LLVMAst.v][LLVMAst.v]]
   - the semantics, of which another paper under submission and cited as such
     in the present submission has been the focus, can be found essentially through
     the folders [[./src/coq/Semantics][Semantics]] and [[./src/coq/Handlers][Handlers]] 
   - the new extended meta-theory, described in Section 6, can be found across the folder [[./src/coq/Theory][Theory]]
   - the symbolic interpreter, described in Section 6, is defined in [[./src/coq/Theory/SymbolicInterpreter.v][SymbolicInterpreter]].
     We fine-tune it on the Helix side in the Prelude to enforce it to run on the right hand-side of
     refinement proofs, and to pair it with the shallow symbolic interpreter for the FHCOL denotation.
   - although as mentioned in Section 6 we work with the relation program logic at a shallow level in
     the current proof for HELIX, we have drafted a more formal take on it in [[./src/coq/Utils/RelLog.v][RelLog]]
   - we have not found the space to detail it in the paper, but the theoretical tools used to
     express the well-definedness of the source semantics in an itree-world is developed in [[./src/coq/Utils/NoFailure.v][NoFailure]] 
   - we have not found the space to detail it in the paper, but the [tfor] itree combinator we
     introduce to help reason generically about [genWhileLoop] is defined in [[./src/coq/Utils/TFor.v][TFor]]

* HELIX

[[https://travis-ci.com/vzaliva/helix][https://travis-ci.com/vzaliva/helix.svg?token=x87izvm44MdTPLHzuxzF&branch=master]]

HELIX project allows for the synthesis of high-performance
implementations of numerical algorithms by providing a certified
compiler for formally-specified DSL.  Based on the existing [[http://spiral.net/][SPIRAL]]
system, HELIX adds the rigor of formal verification of its correctness
using the Coq proof assistant. It formally defines a series of
domain-specific languages starting with HCOL, which represents a
computation data flow. HELIX works by transforming the original
program through a series of intermediate languages, culminating in
LLVM IR.

- HELIX focuses on automatic translation a class of mathematical.
  expressions to code.
- It works by revealing implicit iteration constructs and re-shaping
  them to match target platform parallelizm and vectorization
  capabilities.
- HELIX is rigorously defined and formally verified.
- HELIX is implemented in Coq proof assistant.
- It supports non-linear operators.
- Presently, HELIX uses SPIRAL as an optimization oracle, but it
  certifies its findings.
- LLVM is used machine code generation backend.
- Main application: Cyber-physical systems.

** Example

   An application of HELIX to a real-life situation of high-assurance
   vehicle control [[http://spiral.ece.cmu.edu:8080/pub-spiral/abstract.jsp?id=281][(paper)]] using a dynamic window vehicle control
   approach [[https://doi.org/10.1109/100.580977][(paper)â€‹]] is shown below:

   [[doc/bigpicture.png]]

** Dependencies

   - [[https://coq.inria.fr/][Coq]]
   - [[http://color.inria.fr/][CoLoR]]
   - [[https://github.com/coq-ext-lib/coq-ext-lib][ExtLib]]
   - [[https://github.com/math-classes/math-classes][math-classes]]
   - [[https://github.com/MetaCoq/metacoq][Template Coq]]
   - [[http://flocq.gforge.inria.fr/][Flocq]]
   - [[https://github.com/vellvm/vellvm][Vellvm]] (requires ~coq-ceres~, ~coq-ext-lib~, ~coq-paco~, and ~coq-flocq~) /(manual installation instructions below)/
   - [[https://opensource.janestreet.com/core/][Jane Street Core]]
   - coq-libhyps
   - [[https://github.com/Karmaki/coq-dpdgraph][coq-dpdgraph]] /(optional)/

 To install all required dependenceis:

#+BEGIN_SRC sh
     opam repo add coq-released https://coq.inria.fr/opam/released
     opam pin add coq 8.12.2
     make -j 4 install-deps
#+END_SRC

To install *optional* dependencies:

#+BEGIN_SRC sh
     opam install coq-dpdgraph
#+END_SRC

** Bulding and Running 
*** Install VELLVM dependency:

    You need to manually check out the /itp21/ branch of VELLVM, compile,
    and symlink it as follows:

#+BEGIN_SRC sh
     ln -s path_to_vellvm_checkout/vellvm helix/lib
     ln -s path_to_vellvm_checkout/vellvm/src/ml/libvellvm helix/ml
#+END_SRC

*** Build:
    
#+BEGIN_SRC sh
     make
#+END_SRC
    
*** Run unit tests:

#+BEGIN_SRC sh
     make test
#+END_SRC

** Papers
    - [[http://www.crocodile.org/lord/vzaliva-VSTTE20.pdf][Verified Translation Between Purely Functional and Imperative Domain Specific Languages in HELIX (VSTTE 20)]]
    - [[http://www.crocodile.org/lord/vzaliva-CoqPL19.pdf][Reification of shallow-embedded DSLs in Coq with automated verification (CoqPL 2019)]]
    - [[http://www.crocodile.org/lord/vzaliva-fhpc2018.pdf][HELIX: A Case Study of a Formal Verification of High Performance Program Generation (FHPC 2018)]]
    - [[http://www.crocodile.org/lord/Formal_Verification_of_HCOL_Rewriting_FMCAD15.pdf][Formal Verification of HCOL Rewriting (FMCAD 2015)]]
** Contact

   [[mailto:vzaliva@cmu.edu][Vadim Zaliva]]

