Require Import Helix.LLVMGen.Correctness_Prelude.
Require Import Helix.LLVMGen.IdLemmas.

Import ListNotations.

Set Implicit Arguments.
Set Strict Implicit.

Global Opaque resolve_PVar.

(** Reasoning about when identifiers are bound in certain states *)
Section StateBound.
  Variable count :  IRState -> nat.
  Variable gen : string -> cerr raw_id.

  (* TODO: Injective is sort of a lie... Is there a better thing to call this? *)
  Definition count_gen_injective : Prop
    := forall s1 s1' s2 s2' name1 name2 id1 id2,
      inr (s1', id1) ≡ gen name1 s1 ->
      inr (s2', id2) ≡ gen name2 s2 ->
      count s1 ≢ count s2 ->
      is_correct_prefix name1 ->
      is_correct_prefix name2 ->
      id1 ≢ id2.

  Definition count_gen_mono : Prop
    := forall s1 s2 name id,
      inr (s2, id) ≡ gen name s1 ->
      (count s2 > count s1)%nat.

  Variable INJ : count_gen_injective.
  Variable MONO : count_gen_mono.

  (* Says whether or not a variable has been generated by an earlier IRState,

     I.e., this holds when `id` can be generated using `gen` from a
     state with an earlier counter. The intuition is that `id` ends
     with a number that is *lower* than the count for the current
     state.
   *)
  Definition state_bound (s : IRState) (id : raw_id) : Prop
    := exists name s' s'',
      is_correct_prefix name /\
      (count s' < count s)%nat /\
      inr (s'', id) ≡ gen name s'.

  (* If an id has been bound between two states.

     The primary use for this is in lemmas like, bid_bound_fresh,
     which let us know that since a id was bound between two states,
     it can not possibly collide with an id from an earlier state.
   *)
  Definition state_bound_between (s1 s2 : IRState) (id : raw_id) : Prop
    := exists name s' s'',
      is_correct_prefix name /\
      gen name s1 ≡ inr (s2, id) ->
      ~(state_bound s1 id).
  Proof.
    intros name s1 s2 id ENDS INC.
    intros BOUND.
    destruct BOUND as (n1 & s1' & s1'' & N_S1 & COUNT_S1 & GEN_id).
    symmetry in INC.

    eapply (INJ INC GEN_id); auto.
    lia.
  Qed.

  Lemma gen_state_bound :
    forall name s1 s2 id,
      is_correct_prefix name ->
      gen name s1 ≡ inr (s2, id) ->
      state_bound s2 id.
  Proof.
    intros name s1 s2 id ENDS INC.
    exists name. exists s1. exists s2.
    repeat (split; auto).
    eapply MONO; eauto.
  Qed.

  Lemma gen_state_bound_between :
    forall name s1 s2 id,
      is_correct_prefix name ->
      gen name s1 ≡ inr (s2, id) ->
      state_bound_between s1 s2 id.
  Proof.
    intros name s1 s2 id NEND GEN.
    apply state_bound_bound_between.
    - eapply gen_state_bound; eauto.
    - eapply gen_not_state_bound; eauto.
  Qed.

  Lemma not_id_bound_gen_mono :
    forall name s1 s2 s' id,
      gen name s1 ≡ inr (s2, id) ->
      (count s' <= count s1)%nat ->
      is_correct_prefix name ->
      ~ (state_bound s' id).
  Proof.
    intros name s1 s2 s' id INC LE NE.
    intros BOUND.
    destruct BOUND as (n1 & s1' & s1'' & N_S1 & COUNT_S1 & GEN_id).
    assert (count s1 ≢ count s1') as NEQ by lia.
    eapply INJ.
    symmetry; apply INC.
    apply GEN_id.
    all: auto.
  Qed.
End StateBound.
