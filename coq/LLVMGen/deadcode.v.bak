(* begin deadcode

(** * Freshness scheme
    We axiomatize in this file everything we need to reason
    about VIR identifiers generated by the compiler. We need to do some
    annoyingly fine grained reasoning due to:
    - the freshness monad employed being quite simple (it uses a strictly
    monotonic seed, and hence do not allow for introducing new fresh idents in a
    previously generated window)
    - however the compiler has to generate code in the opposite order of evaluation
    (for the sequence case), hence forcing us to explicitly reason about windows of
    freshness
 *)
Import AlistNotations.
Definition extends (s1 s2 : IRState) (l1 : local_env) : local_env -> Prop :=
  fun l2 =>
    l1 ⊑ l2 /\
    forall id v,
      alist_In id l2 v ->
      ~ alist_In id l1 v ->
      lid_bound_between s1 s2 id.

(* The freshness precondition of a computation [c] such that
   "gen_computation c s1 = T(c), s2"
   It states that the scope of variables generated by the seeds contained in [s1;s2]
   is currently fresh in the initial local state.
   i.e. dom(l) ∩ [s1;s2] = ∅
 *)
Definition is_fresh (s1 s2 : IRState) : local_env -> Prop :=
  fun l => (forall id v, alist_In id l v -> ~(lid_bound_between s1 s2 id)). 

(* The freshness postcondition of the same computation as above.
   It is this time parameterized additionally by the local state from which we
   started the computation, and asserts that all extensions to the domain of l
   that we have performed has been taken from the freshness window provided.
   i.e. dom(l2) \ dom(l1) ⊆ [s1;s2]
 *)
Definition freshness_post (s1 s2 : IRState) (l1 : local_env) : local_env -> Prop :=
  fun l2 => (forall id v, alist_In id l2 v -> ~(alist_In id l1 v) -> lid_bound_between s1 s2 id).

(** ** Fresh identifier generator invariant
      Low and high level invariants ensuring that calls to [incLocal] indeed generate fresh variables.
 *)
Definition incLocal_fresh (l : local_env) (s : IRState) : Prop :=
  forall s' id, incLocal s ≡ inr (s',id) ->
           alist_fresh id l.

Definition concrete_fresh_inv (s : IRState) : config_cfg -> Prop :=
  fun '(_, (l,g)) =>
    forall id v n, alist_In id l v -> n >= local_count s -> id <> Name ("l" @@ string_of_nat n).

(* We need to preserve the concrete invariant, but it is sufficient to get the abstract one of interest *)
Lemma concrete_fresh_fresh: forall s memV l g,
    concrete_fresh_inv s (memV,(l,g)) ->
    incLocal_fresh l s.
Proof.
  intros * FRESH ? ? LU.
  unfold incLocal, incLocalNamed in LU; cbn in *; inv LU.
  unfold alist_fresh.
  match goal with
  | |- ?x ≡ None => destruct x eqn:EQ; auto; exfalso
  end.
  eapply FRESH; eauto.
Qed.

(** * Freshness interface

Let us note FP (resp. FQ) for is_fresh (resp. freshness_post). We have the following lemmas axiomatizing how these two predicates evolve.

     P1. FP s s l

     i.e.  if we give ourself an empty freshness window, the precondition is trivially true
     [is_fresh_empty_window]

     P2. FP s1 s3 l ->
         s2 << s3 ->
         FP s1 s2 l

     i.e. we can always shrink the freshness window
     [is_fresh_shrink_up]

     P3. FP s1 s2 l ->
         incLocal s1 = (s2,r) ->
         alist_fresh r l

     i.e. the whole point of the endeavor, the freshness window indeed generates fresh ids 
     [is_fresh_alist_fresh]

     Q1. FQ s1 s2 l l

     i.e. if we don't extend the state, the postcondition is trivially true
     [freshness_pots_no_extension]

     Q2. FQ s1 s2 l1 l2 ->
         FQ s2 s3 l2 l3 ->
         FQ s1 s3 l1 l3

     i.e. the postcondition is transitive
     [freshness_post_transitive]

     Q3: incLocal s1 = (s2,r) ->
         FQ s1 s2 l l[r->v]

     i.e. the postcondition is compatible with extension by generated variables
     [freshness_post_incLocal]

     PQ. FP s1 s3 l1 ->
         FQ s1 s2 l1 l2 ->
         FP s2 s3 l2

     i.e. linking the pre and postcondition: if we have the precondition for a long computation,
                                 and establish the postcondition at a mid point, we can recover the precondition at this point for the remaining of the computation.
                                 (freshness_chain)

 *)

Section Freshness_Interface.

  (** * P1 *)
  Lemma is_fresh_empty_window :
    forall s l,
      is_fresh s s l.
  Proof.
    intros; red; intros.
    unfold lid_bound_between, state_bound_between.
    intros (? & ? & ? & ? & ? & ?).
    lia.
  Qed.

  (** * P2 *)
  Lemma is_fresh_shrink_up:
    forall s1 s2 s3 l,
      is_fresh s1 s3 l ->
      s2 <<= s3 ->
      is_fresh s1 s2 l.
  Proof.
    intros s1 s2 s3 l FRESH LT.
    unfold is_fresh in *.
    intros id v AIN BOUND.

    eapply (FRESH _ _ AIN).
    eapply state_bound_between_shrink; eauto.
  Qed.

  Lemma is_fresh_shrink:
    forall s1 s2 s3 s4 l,
      is_fresh s1 s4 l ->
      s1 <<= s2 ->
      s3 <<= s4 ->
      is_fresh s2 s3 l.
  Proof.
    intros s1 s2 s3 s4 l FRESH LE1 LE2.
    unfold is_fresh in *.
    intros id v AIN BOUND.

    eapply (FRESH _ _ AIN).
    eapply state_bound_between_shrink; eauto.
  Qed.

  Lemma freshness_fresh: forall s1 s2 l,
      is_fresh s1 s2 l ->
      s1 << s2 ->
      incLocal_fresh l s1.
  Proof.
    intros * NIN LT.
    unfold incLocal_fresh.
    intros s' id GEN.

    (* id is bound in s', which should be between s1 and s2 *)
    assert (lid_bound_between s1 s2 id) as BETWEEN.
    { eapply state_bound_between_shrink.
      -  apply lid_bound_between_incLocal; eauto.
      - lia.
      - unfold IRState_lt in LT.
        apply incLocal_local_count in GEN.
        lia.
    }

    unfold alist_fresh.
    apply alist_find_None.
    intros v IN'.
    eapply In__alist_In in IN'.
    destruct IN' as (v' & IN).
    apply NIN in IN.
    contradiction.
    Unshelve.
    exact Logic.eq.
  Qed.

  Lemma is_fresh_alist_fresh_gen:
    forall s1 s' s2 l id,
      s1 << s2 ->
      is_fresh s1 s2 l ->
      incLocal s1 ≡ inr (s',id) ->
      alist_fresh id l.
  Proof.
    intros * ? ? INCL. 
    eapply freshness_fresh in INCL; eauto.
  Qed.

  (** * P3 *)
  Lemma is_fresh_alist_fresh :
    forall s1 s2 l id,
      is_fresh s1 s2 l ->
      incLocal s1 ≡ inr (s2,id) ->
      alist_fresh id l.
  Proof.
    intros * ? INCL.
    eapply is_fresh_alist_fresh_gen; eauto with irs_lt.
  Qed.

  Lemma is_fresh_incLocal:
    forall s1 s2 s3 r v l,
      incLocal s1 ≡ inr (s2, r) ->
      is_fresh s1 s3 l ->
      is_fresh s2 s3 (alist_add r v l).
  Proof.
    intros * INC FRESH.
    unfold is_fresh in *.
    pose proof INC as INCBAK.
    eapply gen_state_bound_between in INC;
      eauto using incLocalNamed_count_gen_injective, incLocalNamed_count_gen_mono.

    intros id v0 H.
    intros BOUND.

    assert ({r ≡ id} + {r ≢ id}) as [eqr | neqr] by apply rel_dec_p.
    - subst.
      eapply (state_bound_between_id_separate incLocalNamed_count_gen_injective INC BOUND).
      auto.
    - apply In_add_In_ineq in H; eauto.
      apply FRESH in H.
      apply H.
      eapply incLocal_local_count in INCBAK.
      eapply state_bound_between_shrink; eauto.
      lia.
  Qed.

  (** * Q1 *)
  Lemma freshness_post_no_extension: forall s1 s2 l, freshness_post s1 s2 l l.
  Proof.
    intros; red; intros.
    intuition.
  Qed.

  (** * Q2 *)
  Lemma freshness_post_transitive :
    forall s1 s2 s3 l1 l2 l3,
      freshness_post s1 s2 l1 l2 ->
      freshness_post s2 s3 l2 l3 ->
      s1 <<= s2 ->
      s2 <<= s3 ->
      freshness_post s1 s3 l1 l3.
  Proof.
    intros s1 s2 s3 l1 l2 l3 FRESH1 FRESH2 LT1 LT2.
    unfold freshness_post in *.
    intros id v AIN ANIN.

    destruct (alist_In_dec id l2 v) as [INl2 | NINl2].
    - pose proof (FRESH1 _ _ INl2 ANIN).
      eapply state_bound_between_shrink; eauto.
    - pose proof (FRESH2 _ _ AIN NINl2).
      eapply state_bound_between_shrink; eauto.
  Qed.

  (** * Q3 *)
  Lemma freshness_post_inclocal : forall s1 s2 l x v,
      incLocal s1 ≡ inr (s2,x) ->
      freshness_post s1 s2 l (alist_add x v l).
  Proof.
    intros * INC.
    cbn in *.
    apply lid_bound_between_incLocal in INC.
    red; intros.
    destruct (id ?[ Logic.eq ] x) eqn:EQ.
    - rewrite rel_dec_correct in EQ; subst; auto.
    - apply neg_rel_dec_correct in EQ.
      apply In_add_In_ineq in H; auto.
      intuition.
  Qed.

  Lemma freshness_post_incVoid : forall s1 s2 s3 r l l',
      incVoid s2 ≡ inr (s3,r) ->
      freshness_post s1 s2 l l' ->
      freshness_post s1 s3 l l'.
  Proof.
    unfold freshness_post. 
    intros * INC FRESH * IN NIN.
    cbn in *.
    inv INC.
    do 2 red.
    edestruct FRESH; eauto.
  Qed.
  
  (** * PQ *)
  Lemma freshness_chain: forall s1 s2 s3 l1 l2 ,
      is_fresh s1 s3 l1 ->
      freshness_post s1 s2 l1 l2 ->
      s1 <<= s2 ->
      is_fresh s2 s3 l2.
  Proof.
    intros s1 s2 s3 l1 l2 PRE POST LT.
    unfold is_fresh in *.
    unfold freshness_post in *.
    intros id v AIN BOUND.

    destruct (alist_In_dec id l1 v) as [INl1 | NINl1].
    - eapply (PRE _ _ INl1).
      eapply state_bound_between_shrink; eauto.
    - pose proof (POST _ _ AIN NINl1) as BOUND'.
      eapply state_bound_between_separate.
      3: eapply BOUND.
      2: eapply BOUND'.

      apply incLocalNamed_count_gen_injective.
      all: auto.
  Qed.

End Freshness_Interface.

Create HintDb fresh.
Hint Resolve freshness_post_no_extension: fresh.
Hint Resolve freshness_post_inclocal : fresh.

Definition lift_fresh (P: local_env -> Prop) : Rel_cfg := fun _ '(_,(l,_)) => P l.

Notation fresh_pre := (fun s1 s2 => lift_fresh (is_fresh s1 s2)). 
Notation fresh_post := (fun s1 s2 l => lift_fresh (freshness_post s1 s2 l)).

Arguments is_fresh : simpl never.
Arguments freshness_post : simpl never.
Arguments lift_fresh /.

(* Tactic to solve freshness goals *)
Ltac solve_fresh :=
  cbn;
  eauto with fresh;
  match goal with
  | h: is_fresh ?s ?s' ?l |- is_fresh ?s _ ?l => apply is_fresh_shrink_up with (1 := h); solve_local_count
  | h: is_fresh _ ?s _ |- is_fresh _ ?s _ => apply freshness_chain with (1 := h); try solve_local_count; solve_fresh
  | h: freshness_post _ ?s _ ?x |- is_fresh ?s _ ?x => eapply freshness_chain with (2 := h); try solve_local_count; solve_fresh
  | |- freshness_post _ _ _ (alist_add _ _ _) => first [eassumption | eapply freshness_post_inclocal; eassumption | eapply freshness_post_transitive; [ | eapply freshness_post_inclocal; eassumption | solve_local_count | solve_local_count]]; solve_fresh
  | |- freshness_post _ _ _ _ => first [eassumption | eapply freshness_post_transitive; [eassumption | | solve_local_count | solve_local_count]]; solve_fresh
  end.

(* Tactic to solve goals of the shape [alist_fresh]  *)
Ltac solve_alist_fresh :=
  (eapply is_fresh_alist_fresh; now eauto with irs_lt).

(* Tactic to solve goals of the shape l ⊑ l' *)
Ltac solve_sub_alist :=
  (reflexivity
   || (apply alist_le_add; solve_alist_fresh)
   || (etransitivity; try eassumption; []; solve_sub_alist)
  ).

  Lemma state_invariant_sub_alist:
    forall σ s mH mV l1 l2 g,
      l1 ⊑ l2 ->
      state_invariant σ s mH (mV,(l1,g)) ->
      state_invariant σ s mH (mV,(l2,g)). 
  Proof.
    intros * SUB [MEM WF].
    split; auto.
    cbn; intros * LUH LUV.
    eapply MEM in LUH; eapply LUH in LUV; clear MEM LUH.
    destruct v, x; cbn in *; auto.
    - apply SUB in LUV; auto.
    - apply SUB in LUV; auto.
    - destruct LUV as (? & ? & ? & LU & ?); do 2 eexists; repeat split; eauto.
      apply SUB in LU; auto.
  Qed.

  Lemma freshness_ext : forall s1 s2 l1 l2,
      extends s1 s2 l1 l2 ->
      l1 ⊑ l2.
  Proof.
    intros * FRESH; apply FRESH.
  Qed.

  Lemma state_invariant_memory_invariant :
    forall σ s1 s2 s li mH mV l g,
      state_invariant' σ s1 s2 s li mH (mV,(l,g)) ->
      memory_invariant σ s mH (mV,(li,g)).
  Proof.
    intros * H; inv H; auto.
  Qed.
  Hint Resolve state_invariant_memory_invariant : core.
  Import LidBound.

  Lemma sub_alist_add' :
    forall {K V : Type} {RD:RelDec (@Logic.eq K)} {RDC:RelDec_Correct RD} k v (m1 m2 : alist K V),
      alist_fresh k m1 ->
      m1 ⊑ m2 ->
      m1 ⊑ (alist_add k v m2).
  Proof.
    repeat intro.
    unfold alist_In, alist_fresh in *.
    destruct (rel_dec_p k id).
    - subst; rewrite H in H1; inversion H1.
    - apply In_In_add_ineq; auto.
  Qed.

  Lemma state_invariant_add_fresh' :
    ∀ (σ : evalContext) (s1 s2 : IRState) (id : raw_id) (memH : memoryH) (memV : memoryV) 
      (li l : local_env) (g : global_env) (v : uvalue),
      incLocal s1 ≡ inr (s2, id)
      → state_invariant' σ s1 s2 s1 li memH (memV, (l, g))
      → state_invariant' σ s1 s2 s2 li memH (memV, (alist_add id v l, g)).
  Proof.
    intros * INC INV; inv INV.
    constructor.
    - red; intros * LUH LUV.
      erewrite incLocal_Γ in LUV; eauto.
      generalize LUV; intros INLG;
        eapply MINV in INLG; eauto.
    - unfold WF_IRState; erewrite incLocal_Γ; eauto; apply WF.
    - destruct EXT as [EXT DOM].
      split.
      + apply sub_alist_add'; auto.
        eapply is_fresh_alist_fresh; eauto.
      + intros * IN NIN.
        destruct (id ?[ Logic.eq ] id0) eqn:EQ.
        * rewrite rel_dec_correct in EQ; subst; auto using lid_bound_between_incLocal.
        * apply neg_rel_dec_correct in EQ.
          apply In_add_In_ineq in IN; eauto.
    - solve_fresh.
  Qed.

  Lemma incLocal_ineq: forall s1 s2 r,
      incLocal s1 ≡ inr (s2,r) -> s1 <> s2.
  Proof.
    intros.
    Transparent incLocal.
    cbn in *; inv H.
    Opaque incLocal.
    destruct s1; cbn.
    intros EQ; inv EQ.
    eapply Nat.neq_succ_diag_r; eauto.
  Qed.

  Lemma is_fresh_is_safe: forall s1 s2 σ memH memV l g,
      state_invariant'' σ s1 memH (memV, (l,g)) ->
      is_fresh s1 s2 l ->
      Gamma_safe σ s1 s2.
  Proof.
    intros * INV FRESH; red; intros * BOUND ING.
    inv ING.
    inv INV.
    eapply MINV in H; eapply H in H0; clear H MINV.
    cbn in *.
    destruct v.
    eapply FRESH; eauto.
    eapply FRESH; eauto.
    destruct H0 as (? & ? & ? & ? & ?).
    eapply FRESH; eauto.
  Qed.


Lemma fresh_no_lu :
  forall s s' id l g m x dv τ,
    incLocal s ≡ inr (s', id) ->
    incLocal_fresh l s ->
    in_local_or_global_scalar l g m x dv τ ->
    x <> ID_Local id.
Proof.
  intros * INC FRESH IN abs; subst.
  apply FRESH in INC.
  unfold alist_fresh in *.
  cbn in *; rewrite INC in IN; inv IN.
Qed.

Lemma fresh_no_lu_addr :
  forall s s' id l g x ptr,
    incLocal s ≡ inr (s', id) ->
    incLocal_fresh l s ->
    in_local_or_global_addr l g x ptr ->
    x <> ID_Local id.
Proof.
  intros * INC FRESH IN abs; subst.
  apply FRESH in INC.
  unfold alist_fresh in *.
  cbn in *; rewrite INC in IN; inv IN.
Qed.

Lemma ext_local_subalist : forall {R S} memH memV l1 g vH vV l2,
    l1 ⊑ l2 ->
    @ext_local R S memH (mk_config_cfg memV l1 g) (memH, vH) (memV, (l2, (g, vV))).
Proof.
  intros * SUB; cbn; splits; auto.
Qed.

  Definition sub_local_no_aliasing (σ : evalContext) (s : IRState) (ρ1 ρ2 : local_env) (g : global_env) :=
    ρ1 ⊑ ρ2 /\ no_llvm_ptr_aliasing σ s ρ2 g.

Section Ext_Local.

  (** When compiling expressions, we need to carry on the invariant that
      the meaning of the generated expression will be stable by execution of the
      intermediate code corresponding to the evaluation of the second operand.
      To this end, we rely on the fact that this code does not alter the configuration
      except to extend it with fresh bindings.
   *)
  Definition ext_local {R S}: config_helix -> config_cfg -> Rel_cfg_T R S :=
    fun mh '(mi,(li,gi)) '(mh',_) '(m,(l,(g,_))) => mh ≡ mh' /\ mi ≡ m /\ gi ≡ g /\ li ⊑ l.

  Definition sub_local_no_aliasing (σ : evalContext) (s : IRState) (ρ1 ρ2 : local_env) (g : global_env) :=
    ρ1 ⊑ ρ2 /\ no_llvm_ptr_aliasing σ s ρ2 g.

  Definition ext_local_no_aliasing {R S}
             (σ : evalContext) (s  : IRState) :
    config_helix -> config_cfg -> Rel_cfg_T R S
    := fun mh '(mi,(li,gi)) '(mh',_) '(m,(l,(g,_))) =>
         mh ≡ mh' /\ mi ≡ m /\ gi ≡ g /\ sub_local_no_aliasing σ s li l g.

  Lemma in_local_or_global_scalar_ext_local :
    forall ρ1 ρ2 g m x dv τ,
      in_local_or_global_scalar ρ1 g m x dv τ ->
      ρ1 ⊑ ρ2 ->
      in_local_or_global_scalar ρ2 g m x dv τ.
  Proof.
    unfold in_local_or_global_scalar; intros ? ? ? ? [] ? ? IN MONO; auto.
    apply MONO; auto.
  Qed.

  Lemma in_local_or_global_addr_ext_local :
    forall ρ1 ρ2 g x ptr,
      in_local_or_global_addr ρ1 g x ptr ->
      ρ1 ⊑ ρ2 ->
      in_local_or_global_addr ρ2 g x ptr.
  Proof.
    unfold in_local_or_global_addr; intros ρ1 ρ2 g [] ptr IN MONO; auto.
    apply MONO; auto.
  Qed.

  Lemma no_llvm_ptr_aliasing_ext_local :
    forall σ s ρ1 ρ2 g,
      no_llvm_ptr_aliasing σ s ρ1 g ->
      sub_local_no_aliasing σ s ρ1 ρ2 g ->
      no_llvm_ptr_aliasing σ s ρ2 g.
  Proof.
    intros σ s ρ1 ρ2 g ALIAS [EXT EXT_ALIAS].
    eauto.
  Qed.


  Lemma memory_invariant_ext_local :
    forall σ s memH memV ρ1 ρ2 g,
      memory_invariant σ s memH (memV, (ρ1, g)) ->
      ρ1 ⊑ ρ2 ->
      memory_invariant σ s memH (memV, (ρ2, g)).
  Proof.
    intros * MEM_INV EXT_LOCAL.
    red; intros * NTH NTH'.
    specialize (MEM_INV _ _ _ _ NTH NTH').
    destruct v; eauto.
    eapply in_local_or_global_scalar_ext_local; eauto.
    eapply in_local_or_global_scalar_ext_local; eauto.
    repeat destruct MEM_INV as (? & MEM_INV).
    do 3 eexists; splits; eauto.
    eapply in_local_or_global_addr_ext_local; eauto.
  Qed.

End Ext_Local.

Lemma ext_local_refl:
  forall {R S} memH memV l g n v,
    @ext_local R S memH (mk_config_cfg memV l g) (memH, n) (memV, (l, (g, v))).
Proof.
  intros; repeat split; reflexivity.
Qed.

Lemma state_invariant_sub_local_no_aliasing_refl :
  forall l g s mh mv σ,
    state_invariant σ s mh (mv, (l, g)) ->
    sub_local_no_aliasing σ s l l g.
Proof.
  intros l g s mh mv σ SINV.
  destruct SINV. cbn in *.
  split; [reflexivity | eauto].
Qed.


Hint Resolve state_invariant_sub_local_no_aliasing_refl: core.

Lemma sub_local_no_aliasing_transitive :
  forall σ s l0 l1 l2 g,
    sub_local_no_aliasing σ s l0 l1 g ->
    sub_local_no_aliasing σ s l1 l2 g ->
    sub_local_no_aliasing σ s l0 l2 g.
Proof.
  intros σ s l0 l1 l2 g [L0L1 ALIAS1] [L1L2 ALIAS2].
  split; eauto.
  etransitivity; eauto.
Qed.

Lemma sub_local_no_aliasing_add_non_ptr' :
  forall σ s id v l l' g,
    alist_fresh id l ->
    ~ in_Gamma σ s id ->
    WF_IRState σ s ->
    no_llvm_ptr_aliasing σ s l g ->
    sub_local_no_aliasing σ s l' l g ->
    sub_local_no_aliasing σ s l' (alist_add id v l) g.
Proof.
  intros σ s id v l l' g FRESH NGAMMA WF ALIAS [L'L ALIAS'].
  unfold sub_local_no_aliasing.
  split.

  - rewrite L'L. apply alist_le_add; auto.
  - epose proof (no_llvm_ptr_aliasing_not_in_gamma _ ALIAS).
    unfold no_llvm_ptr_aliasing in *.
    intros * H0 H1 H2 H3 H4 H5 H6.
    eapply H;     
      [eauto | eauto | apply H0 | apply H1 | apply H2 | apply H3 | apply H4 | apply H5 | apply H6].
Qed.

Lemma sub_local_no_aliasing_Γ :
  forall σ s1 s2 l1 l2 g,
    sub_local_no_aliasing σ s1 l1 l2 g ->
    Γ s2 ≡ Γ s1 ->
    sub_local_no_aliasing σ s2 l1 l2 g.
Proof.
  intros σ s1 s2 l1 l2 g [L1L2 SUB] GAMMA.
  unfold sub_local_no_aliasing, no_llvm_ptr_aliasing in *.
  rewrite GAMMA.
  auto.
Qed.

Ltac solve_state_invariant :=
  cbn; try eassumption;
  match goal with
  | |- state_invariant _ _ _ (_, (alist_add _ _ _, _)) =>
    eapply state_invariant_add_fresh; [now eauto | solve_alist_fresh | (eassumption || solve_state_invariant) | solve_fresh]
  | |- state_invariant _ _ _ _ =>
    solve [eauto with SolveStateInv]
  end.

Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incBlockNamed; [eassumption | solve_state_invariant] : SolveStateInv.
Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incLocal; [eassumption | solve_state_invariant] : SolveStateInv.
Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incVoid; [eassumption | solve_state_invariant] : SolveStateInv.

Ltac solve_sub_local_no_aliasing_gamma :=
  match goal with
  | H: incLocal ?s1 ≡ inr (?s2, _) |- sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g
    => let GAMMA := fresh "GAMMA"
       in assert (Γ s2 ≡ Γ s1) as GAMMA by eauto with helix_context;
          eapply sub_local_no_aliasing_Γ;
          eauto;
          clear GAMMA

  | H: genNExpr _ ?s1 ≡ inr (?s2, _) |- sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g
    => let GAMMA := fresh "GAMMA"
       in assert (Γ s2 ≡ Γ s1) as GAMMA by eauto with helix_context;
          eapply sub_local_no_aliasing_Γ;
          eauto;
          clear GAMMA

  | H: genNExpr _ ?s1 ≡ inr (?s2, _),
       SUB: sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g |- _
    => let GAMMA := fresh "GAMMA" in
       let SUB2  := fresh "SUB" in
       assert (Γ s1 ≡ Γ s2) as GAMMA by eauto with helix_context;
       epose proof (sub_local_no_aliasing_Γ _ SUB GAMMA);
       clear SUB;
       eauto
  end.


Ltac solve_sub_local_no_aliasing :=
  first [ solve [eapply state_invariant_sub_local_no_aliasing_refl; solve_state_invariant]
        | solve_sub_local_no_aliasing_gamma; solve_sub_local_no_aliasing
        | eapply sub_local_no_aliasing_add_non_ptr';
          [ solve_alist_fresh
          | solve_not_in_gamma
          | eauto
          | eapply state_invariant_no_llvm_ptr_aliasing; solve_state_invariant
          | solve_sub_local_no_aliasing
          ]
        | solve [eapply sub_local_no_aliasing_transitive; eauto]].
Definition state_invariant_pre σ s1 s2 := (state_invariant σ s1 ⩕ fresh_pre s1 s2).
Definition state_invariant_post σ s1 s2 l := (state_invariant σ s2 ⩕ fresh_post s1 s2 l).

Hint Resolve ext_local_refl: core.
Hint Resolve memory_invariant_ext_local: core.
  Definition freshness (s1 s2 : IRState) (l1 : local_env) : local_env -> Prop :=
    fun l2 =>
      l1 ⊑ l2 /\
      forall id v,
        alist_In id l2 v ->
        ~ alist_In id l1 v ->
        lid_bound_between s1 s2 id.

  Lemma freshness_ext : forall s1 s2 l1 l2,
      freshness s1 s2 l1 l2 ->
      l1 ⊑ l2.
  Proof.
    intros * FRESH; apply FRESH.
  Qed.

(* TODO: incLocalNamed should be opaque, and the stability hyp revisited *)

(** Inductive lemma to reason about while loops.
    The code generated is of the shape:
         block_entry ---> nextblock
             |
    ---->loopblock
    |        |
    |    body_entry
    |        |
    |      (body)
    |        |
     ----loopcontblock --> nextblock

 The toplevel lemma [genWhileLoop] will specify a full execution of the loop, starting from [block_entry].
 But to be inductive, this lemma talks only about the looping part:
 - we start from [loopcontblock]
 - we assume that [j] iterations have already been executed
 We therefore assume (I j) initially, and always end with (I n).
 We proceed by induction on the number of iterations remaining, i.e. (n - j).

 Since in order to reach [loopcontblock], we need to have performed at least one iteration, we have the
 following numerical bounds:
 - j > 0
 - j <= n
 - Z.of_nat n < Int64.modulus (or the index would overflow)
 *)
Lemma genWhileLoop_ind:
  forall (prefix : string)
    (loopvar : raw_id)            (* lvar storing the loop index *)
    (loopcontblock : block_id)    (* reentry point from the body back to the loop *)
    (body_entry : block_id)       (* entry point of the body *)
    (body_blocks : list (LLVMAst.block typ)) (* (llvm) body to be iterated *)
    (nextblock : block_id)        (* exit point of the overall loop *)
    (entry_id : block_id)         (* entry point of the overall loop *)
    (s1 s2 : IRState)
    (bks : list (LLVMAst.block typ)) ,

    In body_entry (inputs body_blocks) ->

    (* All labels generated are distinct *)
    wf_ocfg_bid bks ->

    free_in_cfg bks nextblock ->

    forall (n : nat)                     (* Number of iterations *)

      (* Generation of the LLVM code wrapping the loop around bodyV *)
      (HGEN: genWhileLoop prefix (EXP_Integer 0%Z) (EXP_Integer (Z.of_nat n))
                          loopvar loopcontblock body_entry body_blocks [] nextblock s1
                          ≡ inr (s2,(entry_id, bks)))

      (* Computation on the Helix side performed at each cell of the vector, *)
      (*    the counterpart to bodyV (body_blocks) *)
      (bodyH: nat -> mem_block -> itree _ mem_block)
      (j : nat)                       (* Starting iteration *)
      (UPPER_BOUND : 0 < j <= n)
      (NO_OVERFLOW : (Z.of_nat n < Int64.modulus)%Z)

      (* Main relations preserved by iteration *)
      (I : nat -> mem_block -> Rel_cfg),

      (* We assume that we know how to relate the iterations of the bodies *)
      (forall g l mV mH ymem k _label _label',

          (conj_rel (I k ymem)
                    (fun _ '(_, (l, _)) => l @ loopvar ≡ Some (uvalue_of_nat k))
                    mH (mV,(l,g))) ->
          eutt
            (succ_cfg (fun '(memH,vec') '(memV, (l, (g, x))) =>
                         l @ loopvar ≡ Some (uvalue_of_nat k) /\
                         x ≡ inl (_label', loopcontblock) /\
                         I (S k) vec' memH (memV, (l, g))))
            (interp_helix (bodyH k ymem) mH)
            (interp_cfg
               (denote_ocfg (convert_typ [] body_blocks) (_label, body_entry)) g l mV)
      ) ->

      (* Invariant is stable under the administrative bookkeeping that the loop performs *)
      (forall a sa b sb c sc d sd e se msg msg' msg'',
          incBlockNamed msg s1 ≡ inr (sa, a) ->
          incBlockNamed msg' sa ≡ inr (sb, b) ->
          incLocal sb ≡ inr (sc,c) ->
          incLocal sc ≡ inr (sd,d) ->
          incLocalNamed msg'' sd ≡ inr (se, e) ->
          forall k ymem mH l mV g id v,
            id ≡ c \/ id ≡ d \/ id ≡ e \/ id ≡ loopvar ->
                            I k ymem mH (mV, (l, g)) ->
                            I k ymem mH (mV, ((alist_add id v l), g))) ->

    (* Main result. Need to know initially that P holds *)
    forall g l mV mH ymem _label,
      (conj_rel
         (I j ymem)
         (fun _ '(_, (l, _)) => l @ loopvar ≡ Some (uvalue_of_nat (j - 1)))
         mH (mV,(l,g))
      ) ->
      eutt (succ_cfg (fun '(memH,vec') '(memV, (l, (g,x))) =>
              x ≡ inl (loopcontblock, nextblock) /\
              I n vec' memH (memV,(l,g))
           ))
           (interp_helix (build_vec_gen j n bodyH ymem) mH)
           (interp_cfg (denote_ocfg (convert_typ [] bks)
                                                (_label, loopcontblock)) g l mV).
Proof.
  intros * IN UNIQUE_IDENTS NEXTBLOCK_ID * GEN LVAR_FRESH *.
  unfold genWhileLoop in GEN. cbn* in GEN. simp.
  intros BOUND OVER * HBODY STABLE.
  unfold build_vec_gen.

  remember (n - j) as k eqn:K_EQ.
  revert j K_EQ BOUND.
  induction k as [| k IH]; intros j EQidx.

  - (* Base case: we enter through [loopcontblock] and jump out immediately to [nextblock] *)
    intros  BOUND * (INV & LOOPVAR).
    (* Import ProofMode. *)
    (* This ugly preliminary is due to the conversion of types, as most ugly things on Earth are. *)
    apply wf_ocfg_bid_convert_typ with (env := []) in UNIQUE_IDENTS; cbn in UNIQUE_IDENTS; rewrite ?convert_typ_ocfg_app in UNIQUE_IDENTS.
    apply free_in_convert_typ with (env := []) in NEXTBLOCK_ID; cbn in NEXTBLOCK_ID; rewrite ?convert_typ_ocfg_app in NEXTBLOCK_ID.
    cbn; rewrite ?convert_typ_ocfg_app.
    hide_cfg.
    (* We jump into [loopcontblock]
       We denote the content of the block.
     *)
    vjmp.

    cbn.
    assert (n ≡ j) by lia; subst.
    (* replace (j - S j) with 0 by lia. *)

    vred.
    vred.
    vred.
    vstep.
    {
      vstep.
      vstep; solve_lu; reflexivity.
      vstep; reflexivity.
      all: reflexivity.
    }
    vred.
    vstep.
    {
      cbn.
      vstep.
      vstep; solve_lu; reflexivity.
      vstep; reflexivity.
      all:reflexivity.
    }

    (* We now branch to [nextblock] *)
    vbranch_r.
    { vstep.
      solve_lu.
      apply eutt_Ret; repeat f_equal.
      cbn.
      clear - BOUND OVER.
      destruct BOUND as [? _].
      rewrite __arithu; try lia.
      unfold eval_int_icmp.
      rewrite ltu_antisym.
      reflexivity.
    }

    vjmp_out.
    cbn.
    replace (j - j) with 0 by lia.
    cbn; hvred.

    (* We have only touched local variables that the invariant does not care about, we can reestablish it *)
    cbn.
    apply eutt_Ret.
    split.
    + reflexivity.
    + eapply STABLE; eauto.

  - (* Inductive case *)
    Opaque half_modulus.
    cbn in *. intros [LT LE] * (INV & LOOPVAR).
    (* This ugly preliminary is due to the conversion of types, as most ugly things on Earth are. *)
    apply wf_ocfg_bid_convert_typ with (env := []) in UNIQUE_IDENTS; cbn in UNIQUE_IDENTS; rewrite ?convert_typ_ocfg_app in UNIQUE_IDENTS.
    apply free_in_convert_typ with (env := []) in NEXTBLOCK_ID; cbn in NEXTBLOCK_ID; rewrite ?convert_typ_ocfg_app in NEXTBLOCK_ID.
    cbn; rewrite ?convert_typ_ocfg_app.
    cbn in IH; rewrite ?convert_typ_ocfg_app in IH.
    hide_cfg.

    (* RHS : Reducing RHS to apply Body Hypothesis *)
    (* Step 1 : First, process [loopcontblock] and check that k<n, and hence that we do not exit *)
    vjmp.
    cbn.
    vred.
    vred.
    vred.
    vstep.
    {
      vstep.
      vstep; solve_lu.
      vstep; solve_lu.
      all: reflexivity.
    }
    vred.
    vstep.
    {
      cbn; vstep.
      vstep; solve_lu.
      vstep; solve_lu.
      all: reflexivity.
    }
    vred.

    (* Step 2 : Jump to b0, i.e. loopblock (since we have checked k < n). *)
    vbranch_l.
    { cbn; vstep;  try solve_lu.
      rewrite __arithu; try lia.
      apply eutt_Ret.
      repeat f_equal.
      clear - EQidx LT LE OVER.
      unfold eval_int_icmp; rewrite ltu_nat_to_Int64; try lia.
      reflexivity.
    }

    vjmp.
    (* We update [loopvar] via the phi-node *)
    cbn; vred.

    (* BEGIN TODO: infrastructure to deal with non-empty phis *)
    unfold denote_phis.
    cbn.
    rewrite denote_phi_tl; cycle 1.
    {
      inv VG. inversion UNIQUE_IDENTS.
      subst. intro. subst. apply H1. right.
      rewrite map_app.
      apply in_or_app. right. constructor. reflexivity.
    }

    rewrite denote_phi_hd.
    cbn.
    (* TOFIX: broken automation, a wild translate sneaked in where it shouldn't *)
    rewrite translate_bind.
    rewrite ?interp_cfg_to_L3_ret, ?bind_ret_l;
      rewrite ?interp_cfg_to_L3_bind, ?bind_bind.

    vstep.
    {
      setoid_rewrite lookup_alist_add_ineq.
      setoid_rewrite lookup_alist_add_eq. reflexivity. subst.
      intros ?; eapply __fresh; eauto.
    }
    (* TOFIX: broken automation, a wild translate sneaked in where it shouldn't *)
    rewrite translate_ret.
    repeat vred.
    cbn.
    repeat vred.
    (* TOFIX: we leak a [LocalWrite] event *)
    rewrite interp_cfg_to_L3_LW.
    repeat vred.
    subst.
    cbn.
    (* END TODO: infrastructure to deal with non-empty phis *)

    vred.
    (* Step 3 : we jump into the body *)
    vred.

    (* In order to use our body hypothesis, we need to restrict the ambient cfg to only the body *)
    inv VG.
    rewrite denote_bks_prefix; cycle 1; auto.
    {
      match goal with
        |- ?x::?y::?z ≡ _ => replace (x::y::z) with ([x;y]++z)%list by reflexivity
      end; f_equal.
    }
    hide_cfg.
    (* rewrite <- EQidx. *)

    cbn; hvred.
    destruct j as [| j]; [lia |].
    eapply eutt_clo_bind.
    (* We can now use the body hypothesis *)
    eapply HBODY.
    {
      (* A bit of arithmetic is needed to prove that we have the right precondition *)
      split.
      + repeat (eapply STABLE; eauto).

      + rewrite alist_find_add_eq.
        reflexivity.
    }

    (* Step 4 : Back to starting from loopcontblock and have reestablished everything at the next index:
        conclude by IH *)
    introR.
    destruct PRE as (LOOPVAR' & HS & IH').
    subst.
    eapply IH; try lia.
    split; auto.
    Unshelve.
    all: try auto.
Qed.

(* TODO: The freshness statement used in this lemma is obsolete. To fix it *)
(*
Lemma genWhileLoop_correct:
  forall (prefix : string)
    (loopvar : raw_id)            (* lvar storing the loop index *)
    (loopcontblock : block_id)    (* reentry point from the body back to the loop *)
    (body_entry : block_id)       (* entry point of the body *)
    (body_blocks : list (LLVMAst.block typ)) (* (llvm) body to be iterated *)
    (nextblock : block_id)        (* exit point of the overall loop *)
    (entry_id : block_id)         (* entry point of the overall loop *)
    (s1 s2 : IRState)
    (bks : list (LLVMAst.block typ)) ,

    In body_entry (inputs body_blocks) ->

    (* All labels generated are distinct *)
    blk_id_norepet bks ->

    free_in_cfg bks nextblock ->

    forall (n : nat)                     (* Number of iterations *)

      (* Generation of the LLVM code wrapping the loop around bodyV *)
      (HGEN: genWhileLoop prefix (EXP_Integer 0%Z) (EXP_Integer (Z.of_nat n))
                          loopvar loopcontblock body_entry body_blocks [] nextblock s1
                          ≡ inr (s2,(entry_id, bks)))

      (* Computation on the Helix side performed at each cell of the vector, *)
      (*    the counterpart to bodyV (body_blocks) *)
      (bodyH: nat -> mem_block -> itree _ mem_block)
      (NO_OVERFLOW : (Z.of_nat n < Int64.modulus)%Z)

      (* Main relations preserved by iteration *)
      (I : nat -> mem_block -> Rel_cfg)
      (R : Rel_cfg),

      (* We assume that we know how to relate the iterations of the bodies *)
      (forall g l mV mH ymem k _label _label',

          (conj_rel (I k ymem)
                    (fun _ '(_, (l, _)) => l @ loopvar ≡ Some (uvalue_of_nat k))
                    mH (mV,(l,g))) ->
          eutt
            (succ_cfg (fun '(memH,vec') '(memV, (l, (g, x))) =>
                         l @ loopvar ≡ Some (uvalue_of_nat k) /\
                         x ≡ inl (_label', loopcontblock) /\
                         I (S k) vec' memH (memV, (l, g))))
            (interp_helix (bodyH k ymem) mH)
            (interp_cfg
               (denote_ocfg (convert_typ [] body_blocks) (_label, body_entry)) g l mV)
      ) ->

    (* Invariant is stable under the administrative bookkeeping that the loop performs *)
    (forall a sa b sb c sc d sd e se msg msg' msg'',
        incBlockNamed msg s1 ≡ inr (sa, a) ->
        incBlockNamed msg' sa ≡ inr (sb, b) ->
        incLocal sb ≡ inr (sc,c) ->
        incLocal sc ≡ inr (sd,d) ->
        incLocalNamed msg'' sd ≡ inr (se, e) ->
        forall k ymem mH l mV g id v,
          id ≡ c \/ id ≡ d \/ id ≡ e \/ id ≡ loopvar ->
                          I k ymem mH (mV, (l, g)) ->
                          I k ymem mH (mV, ((alist_add id v l), g))) ->

    (* R must be stable by extension of the local env *)
      (forall mH mV g l l',
          l ⊑ l' ->
                            R mH (mV, (l, g)) ->
                            R mH (mV, (l', g))) ->

    (* R must entail the state invariant *)
    (* imp_rel R (state_invariant σ s1) -> *)

    (forall g l mV mH ymem vec,
        (R mH (mV, (l, g)) -> I 0 vec mH (mV, (l, g)) /\ l @ loopvar ≡ Some (uvalue_of_nat 0)) /\
        (I n ymem mH (mV, (l, g)) -> R mH (mV, (l, g)))) ->

    (* Main result. Need to know initially that R holds *)
    forall g l mV mH _label vec,
      R mH (mV,(l,g)) ->
      Freshness.freshness_pre s1 s2 l ->
      eutt (succ_cfg
            (fun '(memH,vec') '(memV, (l, (g,x))) =>
                            (* Consider generalizing? *)

                        (* branches nextblock () *)
                          (x ≡ inl (loopcontblock, nextblock) \/
                          x ≡ inl (entry_id, nextblock)) /\
                          R memH (memV,(l,g))))

           (interp_helix (build_vec n bodyH vec) mH)
           (interp_cfg (denote_ocfg (convert_typ [] bks) (_label ,entry_id)) g l mV).
Proof.

  intros * IN UNIQUE EXIT * GEN * BOUND * IND STABLE STABLE' IND_INV * PRE FRESH.
  pose proof @genWhileLoop_ind as GEN_IND.
  specialize (GEN_IND prefix loopvar loopcontblock body_entry body_blocks nextblock entry_id s1 s2 bks).
  specialize (GEN_IND IN UNIQUE EXIT n GEN).
  unfold genWhileLoop in GEN. cbn* in GEN. simp.
  unfold build_vec.
  destruct n.
  - (* 0th index *)
    cbn.

    apply free_in_convert_typ with (env := []) in EXIT; cbn in EXIT; rewrite ?convert_typ_ocfg_app in EXIT.
    cbn; rewrite ?convert_typ_ocfg_app.
    cbn in GEN_IND; rewrite ?convert_typ_ocfg_app in GEN_IND.

    hide_cfg.
    vjmp.

    vred. vred. vred. vstep.
    {
      cbn.
      vstep.
      vstep; solve_lu; reflexivity.
      vstep; reflexivity.
      all:reflexivity.
    }

    (* We now branch to [nextblock] *)
    vbranch_r.
    { vstep.
      solve_lu.
      apply eutt_Ret; repeat f_equal.
    }

    vjmp_out.
    hvred.
    cbn.
    hvred.

    (* We have only touched local variables that the invariant does not care about, we can reestablish it *)
    clear GEN_IND STABLE.
    apply eutt_Ret. cbn. split. right. reflexivity.
    eapply STABLE'; eauto.
    apply sub_alist_add.
    clean_goal.
    eapply freshness_pre_alist_fresh; [| eassumption].
    eapply freshness_pre_shrink; [eassumption | solve_local_count | solve_local_count].

  - Opaque build_vec_gen.
    cbn.
    cbn in *.

    (* Clean up convert_typ junk *)
    apply free_in_convert_typ with (env := []) in EXIT; cbn in EXIT; rewrite ?convert_typ_ocfg_app in EXIT.
    apply no_repeat_convert_typ with (env := []) in UNIQUE; cbn in UNIQUE; rewrite ?convert_typ_ocfg_app in UNIQUE.

    cbn; rewrite ?convert_typ_ocfg_app.
    cbn in GEN_IND; rewrite ?convert_typ_ocfg_app in GEN_IND.

    hide_cfg.

    Transparent build_vec_gen.
    cbn.

    hvred.

    vjmp.
    cbn.
    vred. vred. vred.
    vstep.
    {
      vstep. vstep; solve_lu.
      vstep; solve_lu.
      all :reflexivity.
    }
    vred.
    vstep. cbn.
    hvred.

    (* Step 1 : Jump to b0, i.e. loopblock (since we have checked k < n). *)
    vbranch_l.
    {
      cbn; vstep.
      match goal with
        |- Maps.lookup ?k (alist_add ?k ?a ?b) ≡ _ =>
        rewrite (lookup_alist_add_eq _ _ b)
      end; reflexivity.
      unfold eval_int_icmp. cbn.
      rewrite ltu_Z_to_Int64; try lia.
      reflexivity.
    }
    vjmp. vred.
    (* We update [loopvar] via the phi-node *)
    cbn; vred.

    focus_single_step_v.

    (* BEGIN TODO: infrastructure to deal with non-empty phis *)
    unfold denote_phis.
    cbn.
    rewrite denote_phi_hd.
    cbn.

    (* TOFIX: broken automation, a wild translate sneaked in where it shouldn't *)
    rewrite translate_bind.
    rewrite ?interp_cfg_to_L3_ret, ?bind_ret_l;
      rewrite ?interp_cfg_to_L3_bind, ?bind_bind.

    vstep. tred. repeat vred.
    unfold map_monad. cbn. vred.
    rewrite interp_cfg_to_L3_LW. vred. vred. vred. vred.

    subst. vred.

    vred.

    inv VG.

    match goal with
    | [ |- context[?hd :: ?hd' :: _ ++ ?tl] ] => remember hd; remember hd'; remember tl
    end.
    assert (AUX:
              (b :: b1 :: (convert_typ nil body_blocks) ++ l0 ≡ [b; b1] ++ (convert_typ nil body_blocks) ++ l0)%list).
    reflexivity.
    rewrite AUX.

    rewrite (denote_ocfg_prefix).
    2 : reflexivity.
    2 : {
      (* Seems like a case we can add to solve_lu. *)
      clear -UNIQUE IN.
      pose proof no_repeat_app_l.
      cbn. apply UNIQUE.
    }

    hide_cfg. rewrite AUX in *. clear AUX.

    vred.
    eapply eutt_clo_bind.

    (* Base case : first iteration of loop. *)
    eapply IND. edestruct IND_INV. split. destruct H. eauto.
    2 : eauto.
    eapply STABLE; eauto.
    unfold Maps.add, Map_alist.
    apply alist_find_add_eq. typeclasses eauto.

    intros. destruct u1. destruct u2 as (? & ?& ? &?).
    destruct p, s. 3 : inversion H. cbn in H. destruct p. destruct H as (LOOPVAR & ID & INV).
    inversion ID; subst.

    unfold build_vec_gen in GEN_IND.
    assert (forall j, S n - S j ≡ n - j) by lia.
    assert (n ≡ n - 0) by lia. rewrite H0. rewrite <- H.
    eapply eutt_Proper_mono.
    2 : {
      eapply GEN_IND.
      - lia.
      - lia.
      - intros. eapply IND. apply H1.
      - eapply STABLE; eauto.
      - split; eauto.
    }

    repeat intro.
    repeat red. repeat red in H1. destruct x; try contradiction.
    destruct p. destruct y as (? & ? & ? & ?). destruct H1. split.
    left; auto. edestruct IND_INV. apply H4. apply H2.

    destruct H as (? & ? & ?). inversion H0.
    Unshelve. eauto. eauto. eauto.
Qed.
 *)

Fixpoint build_vec_gen_aux {E} (from remains: nat)
         (body : nat -> mem_block -> itree E mem_block) : mem_block -> itree E mem_block :=
  fun vec =>
    match remains with
    | 0 => ret vec
    | S remains' =>
      vec' <- body from vec;;
      build_vec_gen_aux (S from) remains' body vec'
    end.

Definition build_vec_gen {E} (from to: nat) :=
  @build_vec_gen_aux E from (to - from).

Definition build_vec {E} := @build_vec_gen E 0.

Lemma incLocal_fresh:
    forall i i' i'' r r' , incLocal i ≡ inr (i', r) ->
                      incLocal i' ≡ inr (i'', r') ->
                      r ≢ r'.
Proof.
  intros. cbn in H, H0. Transparent incLocal. unfold incLocal in *.
  intro. cbn in *. inversion H. inversion H0. subst. cbn in H6. clear -H6.
  cbn in H6. apply Name_inj in H6.
  apply append_simplify_l in H6.
  apply string_of_nat_inj in H6. auto.
  apply Nat.neq_succ_diag_l.
Qed.


end deadcode *)
