(** * Freshness scheme
    We axiomatize in this file everything we need to reason
    about VIR identifiers generated by the compiler. We need to do some
    annoyingly fine grained reasoning due to:
    - the freshness monad employed being quite simple (it uses a strictly
    monotonic seed, and hence do not allow for introducing new fresh idents in a
    previously generated window)
    - however the compiler has to generate code in the opposite order of evaluation
    (for the sequence case), hence forcing us to explicitly reason about windows of
    freshness
 *)
Import AlistNotations.
Definition extends (s1 s2 : IRState) (l1 : local_env) : local_env -> Prop :=
  fun l2 =>
    l1 ⊑ l2 /\
    forall id v,
      alist_In id l2 v ->
      ~ alist_In id l1 v ->
      lid_bound_between s1 s2 id.

(* The freshness precondition of a computation [c] such that
   "gen_computation c s1 = T(c), s2"
   It states that the scope of variables generated by the seeds contained in [s1;s2]
   is currently fresh in the initial local state.
   i.e. dom(l) ∩ [s1;s2] = ∅
 *)
Definition is_fresh (s1 s2 : IRState) : local_env -> Prop :=
  fun l => (forall id v, alist_In id l v -> ~(lid_bound_between s1 s2 id)). 

(* The freshness postcondition of the same computation as above.
   It is this time parameterized additionally by the local state from which we
   started the computation, and asserts that all extensions to the domain of l
   that we have performed has been taken from the freshness window provided.
   i.e. dom(l2) \ dom(l1) ⊆ [s1;s2]
 *)
Definition freshness_post (s1 s2 : IRState) (l1 : local_env) : local_env -> Prop :=
  fun l2 => (forall id v, alist_In id l2 v -> ~(alist_In id l1 v) -> lid_bound_between s1 s2 id).

(** ** Fresh identifier generator invariant
      Low and high level invariants ensuring that calls to [incLocal] indeed generate fresh variables.
 *)
Definition incLocal_fresh (l : local_env) (s : IRState) : Prop :=
  forall s' id, incLocal s ≡ inr (s',id) ->
           alist_fresh id l.

Definition concrete_fresh_inv (s : IRState) : config_cfg -> Prop :=
  fun '(_, (l,g)) =>
    forall id v n, alist_In id l v -> n >= local_count s -> id <> Name ("l" @@ string_of_nat n).

(* We need to preserve the concrete invariant, but it is sufficient to get the abstract one of interest *)
Lemma concrete_fresh_fresh: forall s memV l g,
    concrete_fresh_inv s (memV,(l,g)) ->
    incLocal_fresh l s.
Proof.
  intros * FRESH ? ? LU.
  unfold incLocal, incLocalNamed in LU; cbn in *; inv LU.
  unfold alist_fresh.
  match goal with
  | |- ?x ≡ None => destruct x eqn:EQ; auto; exfalso
  end.
  eapply FRESH; eauto.
Qed.

(** * Freshness interface

Let us note FP (resp. FQ) for is_fresh (resp. freshness_post). We have the following lemmas axiomatizing how these two predicates evolve.

     P1. FP s s l

     i.e.  if we give ourself an empty freshness window, the precondition is trivially true
     [is_fresh_empty_window]

     P2. FP s1 s3 l ->
         s2 << s3 ->
         FP s1 s2 l

     i.e. we can always shrink the freshness window
     [is_fresh_shrink_up]

     P3. FP s1 s2 l ->
         incLocal s1 = (s2,r) ->
         alist_fresh r l

     i.e. the whole point of the endeavor, the freshness window indeed generates fresh ids 
     [is_fresh_alist_fresh]

     Q1. FQ s1 s2 l l

     i.e. if we don't extend the state, the postcondition is trivially true
     [freshness_pots_no_extension]

     Q2. FQ s1 s2 l1 l2 ->
         FQ s2 s3 l2 l3 ->
         FQ s1 s3 l1 l3

     i.e. the postcondition is transitive
     [freshness_post_transitive]

     Q3: incLocal s1 = (s2,r) ->
         FQ s1 s2 l l[r->v]

     i.e. the postcondition is compatible with extension by generated variables
     [freshness_post_incLocal]

     PQ. FP s1 s3 l1 ->
         FQ s1 s2 l1 l2 ->
         FP s2 s3 l2

     i.e. linking the pre and postcondition: if we have the precondition for a long computation,
                                 and establish the postcondition at a mid point, we can recover the precondition at this point for the remaining of the computation.
                                 (freshness_chain)

 *)

Section Freshness_Interface.

  (** * P1 *)
  Lemma is_fresh_empty_window :
    forall s l,
      is_fresh s s l.
  Proof.
    intros; red; intros.
    unfold lid_bound_between, state_bound_between.
    intros (? & ? & ? & ? & ? & ?).
    lia.
  Qed.

  (** * P2 *)
  Lemma is_fresh_shrink_up:
    forall s1 s2 s3 l,
      is_fresh s1 s3 l ->
      s2 <<= s3 ->
      is_fresh s1 s2 l.
  Proof.
    intros s1 s2 s3 l FRESH LT.
    unfold is_fresh in *.
    intros id v AIN BOUND.

    eapply (FRESH _ _ AIN).
    eapply state_bound_between_shrink; eauto.
  Qed.

  Lemma is_fresh_shrink:
    forall s1 s2 s3 s4 l,
      is_fresh s1 s4 l ->
      s1 <<= s2 ->
      s3 <<= s4 ->
      is_fresh s2 s3 l.
  Proof.
    intros s1 s2 s3 s4 l FRESH LE1 LE2.
    unfold is_fresh in *.
    intros id v AIN BOUND.

    eapply (FRESH _ _ AIN).
    eapply state_bound_between_shrink; eauto.
  Qed.

  Lemma freshness_fresh: forall s1 s2 l,
      is_fresh s1 s2 l ->
      s1 << s2 ->
      incLocal_fresh l s1.
  Proof.
    intros * NIN LT.
    unfold incLocal_fresh.
    intros s' id GEN.

    (* id is bound in s', which should be between s1 and s2 *)
    assert (lid_bound_between s1 s2 id) as BETWEEN.
    { eapply state_bound_between_shrink.
      -  apply lid_bound_between_incLocal; eauto.
      - lia.
      - unfold IRState_lt in LT.
        apply incLocal_local_count in GEN.
        lia.
    }

    unfold alist_fresh.
    apply alist_find_None.
    intros v IN'.
    eapply In__alist_In in IN'.
    destruct IN' as (v' & IN).
    apply NIN in IN.
    contradiction.
    Unshelve.
    exact Logic.eq.
  Qed.

  Lemma is_fresh_alist_fresh_gen:
    forall s1 s' s2 l id,
      s1 << s2 ->
      is_fresh s1 s2 l ->
      incLocal s1 ≡ inr (s',id) ->
      alist_fresh id l.
  Proof.
    intros * ? ? INCL. 
    eapply freshness_fresh in INCL; eauto.
  Qed.

  (** * P3 *)
  Lemma is_fresh_alist_fresh :
    forall s1 s2 l id,
      is_fresh s1 s2 l ->
      incLocal s1 ≡ inr (s2,id) ->
      alist_fresh id l.
  Proof.
    intros * ? INCL.
    eapply is_fresh_alist_fresh_gen; eauto with irs_lt.
  Qed.

  Lemma is_fresh_incLocal:
    forall s1 s2 s3 r v l,
      incLocal s1 ≡ inr (s2, r) ->
      is_fresh s1 s3 l ->
      is_fresh s2 s3 (alist_add r v l).
  Proof.
    intros * INC FRESH.
    unfold is_fresh in *.
    pose proof INC as INCBAK.
    eapply gen_state_bound_between in INC;
      eauto using incLocalNamed_count_gen_injective, incLocalNamed_count_gen_mono.

    intros id v0 H.
    intros BOUND.

    assert ({r ≡ id} + {r ≢ id}) as [eqr | neqr] by apply rel_dec_p.
    - subst.
      eapply (state_bound_between_id_separate incLocalNamed_count_gen_injective INC BOUND).
      auto.
    - apply In_add_In_ineq in H; eauto.
      apply FRESH in H.
      apply H.
      eapply incLocal_local_count in INCBAK.
      eapply state_bound_between_shrink; eauto.
      lia.
  Qed.

  (** * Q1 *)
  Lemma freshness_post_no_extension: forall s1 s2 l, freshness_post s1 s2 l l.
  Proof.
    intros; red; intros.
    intuition.
  Qed.

  (** * Q2 *)
  Lemma freshness_post_transitive :
    forall s1 s2 s3 l1 l2 l3,
      freshness_post s1 s2 l1 l2 ->
      freshness_post s2 s3 l2 l3 ->
      s1 <<= s2 ->
      s2 <<= s3 ->
      freshness_post s1 s3 l1 l3.
  Proof.
    intros s1 s2 s3 l1 l2 l3 FRESH1 FRESH2 LT1 LT2.
    unfold freshness_post in *.
    intros id v AIN ANIN.

    destruct (alist_In_dec id l2 v) as [INl2 | NINl2].
    - pose proof (FRESH1 _ _ INl2 ANIN).
      eapply state_bound_between_shrink; eauto.
    - pose proof (FRESH2 _ _ AIN NINl2).
      eapply state_bound_between_shrink; eauto.
  Qed.

  (** * Q3 *)
  Lemma freshness_post_inclocal : forall s1 s2 l x v,
      incLocal s1 ≡ inr (s2,x) ->
      freshness_post s1 s2 l (alist_add x v l).
  Proof.
    intros * INC.
    cbn in *.
    apply lid_bound_between_incLocal in INC.
    red; intros.
    destruct (id ?[ Logic.eq ] x) eqn:EQ.
    - rewrite rel_dec_correct in EQ; subst; auto.
    - apply neg_rel_dec_correct in EQ.
      apply In_add_In_ineq in H; auto.
      intuition.
  Qed.

  Lemma freshness_post_incVoid : forall s1 s2 s3 r l l',
      incVoid s2 ≡ inr (s3,r) ->
      freshness_post s1 s2 l l' ->
      freshness_post s1 s3 l l'.
  Proof.
    unfold freshness_post. 
    intros * INC FRESH * IN NIN.
    cbn in *.
    inv INC.
    do 2 red.
    edestruct FRESH; eauto.
  Qed.
  
  (** * PQ *)
  Lemma freshness_chain: forall s1 s2 s3 l1 l2 ,
      is_fresh s1 s3 l1 ->
      freshness_post s1 s2 l1 l2 ->
      s1 <<= s2 ->
      is_fresh s2 s3 l2.
  Proof.
    intros s1 s2 s3 l1 l2 PRE POST LT.
    unfold is_fresh in *.
    unfold freshness_post in *.
    intros id v AIN BOUND.

    destruct (alist_In_dec id l1 v) as [INl1 | NINl1].
    - eapply (PRE _ _ INl1).
      eapply state_bound_between_shrink; eauto.
    - pose proof (POST _ _ AIN NINl1) as BOUND'.
      eapply state_bound_between_separate.
      3: eapply BOUND.
      2: eapply BOUND'.

      apply incLocalNamed_count_gen_injective.
      all: auto.
  Qed.

End Freshness_Interface.

Create HintDb fresh.
Hint Resolve freshness_post_no_extension: fresh.
Hint Resolve freshness_post_inclocal : fresh.

Definition lift_fresh (P: local_env -> Prop) : Rel_cfg := fun _ '(_,(l,_)) => P l.

Notation fresh_pre := (fun s1 s2 => lift_fresh (is_fresh s1 s2)). 
Notation fresh_post := (fun s1 s2 l => lift_fresh (freshness_post s1 s2 l)).

Arguments is_fresh : simpl never.
Arguments freshness_post : simpl never.
Arguments lift_fresh /.

(* Tactic to solve freshness goals *)
Ltac solve_fresh :=
  cbn;
  eauto with fresh;
  match goal with
  | h: is_fresh ?s ?s' ?l |- is_fresh ?s _ ?l => apply is_fresh_shrink_up with (1 := h); solve_local_count
  | h: is_fresh _ ?s _ |- is_fresh _ ?s _ => apply freshness_chain with (1 := h); try solve_local_count; solve_fresh
  | h: freshness_post _ ?s _ ?x |- is_fresh ?s _ ?x => eapply freshness_chain with (2 := h); try solve_local_count; solve_fresh
  | |- freshness_post _ _ _ (alist_add _ _ _) => first [eassumption | eapply freshness_post_inclocal; eassumption | eapply freshness_post_transitive; [ | eapply freshness_post_inclocal; eassumption | solve_local_count | solve_local_count]]; solve_fresh
  | |- freshness_post _ _ _ _ => first [eassumption | eapply freshness_post_transitive; [eassumption | | solve_local_count | solve_local_count]]; solve_fresh
  end.

(* Tactic to solve goals of the shape [alist_fresh]  *)
Ltac solve_alist_fresh :=
  (eapply is_fresh_alist_fresh; now eauto with irs_lt).

(* Tactic to solve goals of the shape l ⊑ l' *)
Ltac solve_sub_alist :=
  (reflexivity
   || (apply alist_le_add; solve_alist_fresh)
   || (etransitivity; try eassumption; []; solve_sub_alist)
  ).


Lemma fresh_no_lu :
  forall s s' id l g m x dv τ,
    incLocal s ≡ inr (s', id) ->
    incLocal_fresh l s ->
    in_local_or_global_scalar l g m x dv τ ->
    x <> ID_Local id.
Proof.
  intros * INC FRESH IN abs; subst.
  apply FRESH in INC.
  unfold alist_fresh in *.
  cbn in *; rewrite INC in IN; inv IN.
Qed.

Lemma fresh_no_lu_addr :
  forall s s' id l g x ptr,
    incLocal s ≡ inr (s', id) ->
    incLocal_fresh l s ->
    in_local_or_global_addr l g x ptr ->
    x <> ID_Local id.
Proof.
  intros * INC FRESH IN abs; subst.
  apply FRESH in INC.
  unfold alist_fresh in *.
  cbn in *; rewrite INC in IN; inv IN.
Qed.

Lemma ext_local_subalist : forall {R S} memH memV l1 g vH vV l2,
    l1 ⊑ l2 ->
    @ext_local R S memH (mk_config_cfg memV l1 g) (memH, vH) (memV, (l2, (g, vV))).
Proof.
  intros * SUB; cbn; splits; auto.
Qed.

  Definition sub_local_no_aliasing (σ : evalContext) (s : IRState) (ρ1 ρ2 : local_env) (g : global_env) :=
    ρ1 ⊑ ρ2 /\ no_llvm_ptr_aliasing σ s ρ2 g.

Section Ext_Local.

  (** When compiling expressions, we need to carry on the invariant that
      the meaning of the generated expression will be stable by execution of the
      intermediate code corresponding to the evaluation of the second operand.
      To this end, we rely on the fact that this code does not alter the configuration
      except to extend it with fresh bindings.
   *)
  Definition ext_local {R S}: config_helix -> config_cfg -> Rel_cfg_T R S :=
    fun mh '(mi,(li,gi)) '(mh',_) '(m,(l,(g,_))) => mh ≡ mh' /\ mi ≡ m /\ gi ≡ g /\ li ⊑ l.

  Definition sub_local_no_aliasing (σ : evalContext) (s : IRState) (ρ1 ρ2 : local_env) (g : global_env) :=
    ρ1 ⊑ ρ2 /\ no_llvm_ptr_aliasing σ s ρ2 g.

  Definition ext_local_no_aliasing {R S}
             (σ : evalContext) (s  : IRState) :
    config_helix -> config_cfg -> Rel_cfg_T R S
    := fun mh '(mi,(li,gi)) '(mh',_) '(m,(l,(g,_))) =>
         mh ≡ mh' /\ mi ≡ m /\ gi ≡ g /\ sub_local_no_aliasing σ s li l g.

  Lemma in_local_or_global_scalar_ext_local :
    forall ρ1 ρ2 g m x dv τ,
      in_local_or_global_scalar ρ1 g m x dv τ ->
      ρ1 ⊑ ρ2 ->
      in_local_or_global_scalar ρ2 g m x dv τ.
  Proof.
    unfold in_local_or_global_scalar; intros ? ? ? ? [] ? ? IN MONO; auto.
    apply MONO; auto.
  Qed.

  Lemma in_local_or_global_addr_ext_local :
    forall ρ1 ρ2 g x ptr,
      in_local_or_global_addr ρ1 g x ptr ->
      ρ1 ⊑ ρ2 ->
      in_local_or_global_addr ρ2 g x ptr.
  Proof.
    unfold in_local_or_global_addr; intros ρ1 ρ2 g [] ptr IN MONO; auto.
    apply MONO; auto.
  Qed.

  Lemma no_llvm_ptr_aliasing_ext_local :
    forall σ s ρ1 ρ2 g,
      no_llvm_ptr_aliasing σ s ρ1 g ->
      sub_local_no_aliasing σ s ρ1 ρ2 g ->
      no_llvm_ptr_aliasing σ s ρ2 g.
  Proof.
    intros σ s ρ1 ρ2 g ALIAS [EXT EXT_ALIAS].
    eauto.
  Qed.


  Lemma memory_invariant_ext_local :
    forall σ s memH memV ρ1 ρ2 g,
      memory_invariant σ s memH (memV, (ρ1, g)) ->
      ρ1 ⊑ ρ2 ->
      memory_invariant σ s memH (memV, (ρ2, g)).
  Proof.
    intros * MEM_INV EXT_LOCAL.
    red; intros * NTH NTH'.
    specialize (MEM_INV _ _ _ _ NTH NTH').
    destruct v; eauto.
    eapply in_local_or_global_scalar_ext_local; eauto.
    eapply in_local_or_global_scalar_ext_local; eauto.
    repeat destruct MEM_INV as (? & MEM_INV).
    do 3 eexists; splits; eauto.
    eapply in_local_or_global_addr_ext_local; eauto.
  Qed.

End Ext_Local.

Lemma ext_local_refl:
  forall {R S} memH memV l g n v,
    @ext_local R S memH (mk_config_cfg memV l g) (memH, n) (memV, (l, (g, v))).
Proof.
  intros; repeat split; reflexivity.
Qed.

Lemma state_invariant_sub_local_no_aliasing_refl :
  forall l g s mh mv σ,
    state_invariant σ s mh (mv, (l, g)) ->
    sub_local_no_aliasing σ s l l g.
Proof.
  intros l g s mh mv σ SINV.
  destruct SINV. cbn in *.
  split; [reflexivity | eauto].
Qed.


Hint Resolve state_invariant_sub_local_no_aliasing_refl: core.

Lemma sub_local_no_aliasing_transitive :
  forall σ s l0 l1 l2 g,
    sub_local_no_aliasing σ s l0 l1 g ->
    sub_local_no_aliasing σ s l1 l2 g ->
    sub_local_no_aliasing σ s l0 l2 g.
Proof.
  intros σ s l0 l1 l2 g [L0L1 ALIAS1] [L1L2 ALIAS2].
  split; eauto.
  etransitivity; eauto.
Qed.

Lemma sub_local_no_aliasing_add_non_ptr' :
  forall σ s id v l l' g,
    alist_fresh id l ->
    ~ in_Gamma σ s id ->
    WF_IRState σ s ->
    no_llvm_ptr_aliasing σ s l g ->
    sub_local_no_aliasing σ s l' l g ->
    sub_local_no_aliasing σ s l' (alist_add id v l) g.
Proof.
  intros σ s id v l l' g FRESH NGAMMA WF ALIAS [L'L ALIAS'].
  unfold sub_local_no_aliasing.
  split.

  - rewrite L'L. apply alist_le_add; auto.
  - epose proof (no_llvm_ptr_aliasing_not_in_gamma _ ALIAS).
    unfold no_llvm_ptr_aliasing in *.
    intros * H0 H1 H2 H3 H4 H5 H6.
    eapply H;     
      [eauto | eauto | apply H0 | apply H1 | apply H2 | apply H3 | apply H4 | apply H5 | apply H6].
Qed.

Lemma sub_local_no_aliasing_Γ :
  forall σ s1 s2 l1 l2 g,
    sub_local_no_aliasing σ s1 l1 l2 g ->
    Γ s2 ≡ Γ s1 ->
    sub_local_no_aliasing σ s2 l1 l2 g.
Proof.
  intros σ s1 s2 l1 l2 g [L1L2 SUB] GAMMA.
  unfold sub_local_no_aliasing, no_llvm_ptr_aliasing in *.
  rewrite GAMMA.
  auto.
Qed.

Ltac solve_state_invariant :=
  cbn; try eassumption;
  match goal with
  | |- state_invariant _ _ _ (_, (alist_add _ _ _, _)) =>
    eapply state_invariant_add_fresh; [now eauto | solve_alist_fresh | (eassumption || solve_state_invariant) | solve_fresh]
  | |- state_invariant _ _ _ _ =>
    solve [eauto with SolveStateInv]
  end.

Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incBlockNamed; [eassumption | solve_state_invariant] : SolveStateInv.
Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incLocal; [eassumption | solve_state_invariant] : SolveStateInv.
Hint Extern 2 (state_invariant _ _ _ _) => eapply state_invariant_incVoid; [eassumption | solve_state_invariant] : SolveStateInv.

Ltac solve_sub_local_no_aliasing_gamma :=
  match goal with
  | H: incLocal ?s1 ≡ inr (?s2, _) |- sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g
    => let GAMMA := fresh "GAMMA"
       in assert (Γ s2 ≡ Γ s1) as GAMMA by eauto with helix_context;
          eapply sub_local_no_aliasing_Γ;
          eauto;
          clear GAMMA

  | H: genNExpr _ ?s1 ≡ inr (?s2, _) |- sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g
    => let GAMMA := fresh "GAMMA"
       in assert (Γ s2 ≡ Γ s1) as GAMMA by eauto with helix_context;
          eapply sub_local_no_aliasing_Γ;
          eauto;
          clear GAMMA

  | H: genNExpr _ ?s1 ≡ inr (?s2, _),
       SUB: sub_local_no_aliasing ?σ ?s2 ?l1 ?l2 ?g |- _
    => let GAMMA := fresh "GAMMA" in
       let SUB2  := fresh "SUB" in
       assert (Γ s1 ≡ Γ s2) as GAMMA by eauto with helix_context;
       epose proof (sub_local_no_aliasing_Γ _ SUB GAMMA);
       clear SUB;
       eauto
  end.


Ltac solve_sub_local_no_aliasing :=
  first [ solve [eapply state_invariant_sub_local_no_aliasing_refl; solve_state_invariant]
        | solve_sub_local_no_aliasing_gamma; solve_sub_local_no_aliasing
        | eapply sub_local_no_aliasing_add_non_ptr';
          [ solve_alist_fresh
          | solve_not_in_gamma
          | eauto
          | eapply state_invariant_no_llvm_ptr_aliasing; solve_state_invariant
          | solve_sub_local_no_aliasing
          ]
        | solve [eapply sub_local_no_aliasing_transitive; eauto]].
Definition state_invariant_pre σ s1 s2 := (state_invariant σ s1 ⩕ fresh_pre s1 s2).
Definition state_invariant_post σ s1 s2 l := (state_invariant σ s2 ⩕ fresh_post s1 s2 l).

Hint Resolve ext_local_refl: core.
Hint Resolve memory_invariant_ext_local: core.
