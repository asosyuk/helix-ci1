(** * Local identifiers and freshness frames

    Specialization of [VariableBinding] to local identifiers.
 *)

Require Import Helix.LLVMGen.Correctness_Prelude.
Require Import Helix.LLVMGen.VariableBinding.
Require Import Helix.LLVMGen.IdLemmas.
Require Import Helix.LLVMGen.StateCounters.
Set Implicit Arguments.
Set Strict Implicit.

Section LidBound.  
  (* Says that a given local id would have been generated by an earlier IRState *)
  Definition lid_bound (s : IRState) (lid: local_id) : Prop
    := state_bound local_count incLocalNamed s lid.

  Definition lid_bound_between (s1 s2 : IRState) (lid : local_id) : Prop
    := state_bound_between local_count incLocalNamed s1 s2 lid.

  Lemma incLocalNamed_count_gen_injective :
    count_gen_injective local_count incLocalNamed.
  Proof.
    unfold count_gen_injective.
    intros s1 s1' s2 s2' name1 name2 id1 id2 GEN1 GEN2 H1 H2 H3.

    inv GEN1.
    inv GEN2.

    intros CONTRA.
    apply Name_inj in CONTRA.
    apply valid_prefix_string_of_nat_forward in CONTRA; auto.
    intuition.
  Qed.

  Lemma lid_bound_fresh :
    ∀ (s1 s2 : IRState) (id1 id2 : local_id),
      lid_bound s1 id1 →
      lid_bound_between s1 s2 id2 → id1 ≢ id2.
  Proof.
    intros s1 s2 lid lid' BOUND BETWEEN.
    eapply state_bound_fresh; eauto.
    apply incLocalNamed_count_gen_injective.
  Qed.

  Lemma incLocalNamed_count_gen_mono :
    count_gen_mono local_count incLocalNamed.
  Proof.
    unfold count_gen_mono.
    intros s1 s2 name id H.

    cbn in H; simp.
    cbn. auto.
  Qed.

  Lemma lid_bound_incLocalNamed :
    forall name s1 s2 id,
      is_correct_prefix name ->
      incLocalNamed name s1 ≡ inr (s2, id) ->
      lid_bound s2 id.
  Proof.
    intros name s1 s2 id NENDS GEN.
    exists name. exists s1. exists s2.
    cbn in GEN; simp.
    repeat split; auto.
  Qed.

  Lemma not_lid_bound_incLocalNamed :
    forall name s1 s2 id,
      is_correct_prefix name ->
      incLocalNamed name s1 ≡ inr (s2, id) ->
      ~ lid_bound s1 id.
  Proof.
    intros name s1 s2 id NENDS GEN.
    eapply not_id_bound_gen_mono; eauto.
    apply incLocalNamed_count_gen_injective.
  Qed.

  Lemma lid_bound_between_incLocalNamed :
    forall name s1 s2 id,
      is_correct_prefix name ->
      incLocalNamed name s1 ≡ inr (s2, id) ->
      lid_bound_between s1 s2 id.
  Proof.
    intros name s1 s2 id NENDS GEN.
    apply state_bound_bound_between.
    - eapply lid_bound_incLocalNamed; eauto.
    - eapply not_lid_bound_incLocalNamed; eauto.
  Qed.

  Lemma newLocalVar_lid_bound :
    forall s1 s2 prefix τ id,
      is_correct_prefix prefix ->
      newLocalVar τ prefix s1 ≡ inr (s2, id) ->
      lid_bound s2 id.
  Proof.
    intros * PRE EQ; inv EQ; cbn.
    do 3 eexists; repeat split; eauto.
  Qed.

  Lemma not_lid_bound_incLocal :
    forall s1 s2 id,
      incLocal s1 ≡ inr (s2, id) ->
      ~ lid_bound s1 id.
  Proof.
    intros s1 s2 id GEN.
    Transparent incLocal.
    eapply not_lid_bound_incLocalNamed; eauto.
    reflexivity.
    Opaque incLocal.
  Qed.

  Lemma lid_bound_between_incLocal :
    forall s1 s2 id,
      incLocal s1 ≡ inr (s2, id) ->
      lid_bound_between s1 s2 id.
  Proof.
    intros s1 s2 id GEN.
    Transparent incLocal.
    eapply lid_bound_between_incLocalNamed; eauto.
    reflexivity.
    Opaque incLocal.
  Qed.

  Lemma lid_bound_between_newLocalVar :
    forall τ s1 s2 r str,
      is_correct_prefix str ->
      newLocalVar τ str s1 ≡ inr (s2, r) ->
      lid_bound_between s1 s2 r.
  Proof.
    Transparent newLocalVar.
    cbn. intros * E H. inversion H. subst. clear H.
    unfold lid_bound_between, state_bound_between.
    eexists. eexists. eexists.
    split; try split; try split; eauto.
    2 : cbn; reflexivity. auto.
    Opaque newLocalVar.
  Qed.

  Lemma lid_bound_incBlockNamed_mono :
    forall name s1 s2 bid bid',
      lid_bound s1 bid ->
      incBlockNamed name s1 ≡ inr (s2, bid') ->
      lid_bound s2 bid.
  Proof.
    intros name s1 s2 bid bid' (lname & s' & s'' & NEND & COUNT1 & COUNT2) INC.
    exists lname. exists s'. exists s''.
    repeat (split; auto).
    erewrite incBlockNamed_local_count with (s':=s2); eauto.
  Qed.

  (* TODO: typeclasses for these mono lemmas to make automation easier? *)
  Lemma lid_bound_incVoid_mono :
    forall s1 s2 bid bid',
      lid_bound s1 bid ->
      incVoid s1 ≡ inr (s2, bid') ->
      lid_bound s2 bid.
  Proof.
    intros s1 s2 bid bid' BOUND INC.
    destruct BOUND as (n1 & s1' & s1'' & N_S1 & COUNT_S1 & GEN_bid).
    unfold lid_bound.
    exists n1. exists s1'. exists s1''.
    intuition.
    apply incVoid_local_count in INC.
    lia.
  Qed.

  Lemma lid_bound_incLocal_mono :
    forall s1 s2 bid bid',
      lid_bound s1 bid ->
      incLocal s1 ≡ inr (s2, bid') ->
      lid_bound s2 bid.
  Proof.
    intros s1 s2 bid bid' BOUND INC.
    destruct BOUND as (n1 & s1' & s1'' & N_S1 & COUNT_S1 & GEN_bid).
    unfold lid_bound.
    exists n1. exists s1'. exists s1''.
    intuition.
    apply incLocal_local_count in INC.
    lia.
  Qed.

  Lemma incLocalNamed_lid_bound :
    forall s1 s2 id name,
      is_correct_prefix name ->
      incLocalNamed name s1 ≡ inr (s2, id) ->
      lid_bound s2 id.
  Proof.
    intros s1 s2 id name CORR INC.
    unfold lid_bound.
    unfold state_bound.
    exists name. exists s1. exists s2.
    split; eauto.
    split; auto.
    pose proof incLocalNamed_local_count INC.
    lia.
  Qed.

  Lemma incLocal_lid_bound :
    forall s1 s2 id,
      incLocal s1 ≡ inr (s2, id) ->
      lid_bound s2 id.
  Proof.
    intros s1 s2 id INC.
    Transparent incLocal.
    unfold incLocal in *.
    eapply incLocalNamed_lid_bound; eauto.
    reflexivity.
    Opaque incLocal.
  Qed.

  Lemma lid_bound_earlier :
    forall (s1 s2 s3 : IRState) (id1 id2 : local_id),
      lid_bound s1 id1 ->
      lid_bound_between s2 s3 id2 ->
      s1 <<= s2 ->
      id1 ≢ id2.
  Proof.
    intros s1 s2 s3 id1 id2 BOUND BETWEEN COUNTS.
    do 2 red in BOUND, BETWEEN.
    destruct BOUND as (name1 & s1' & s1'' & PREF1 & COUNT1 & GEN1).
    destruct BETWEEN as (name2 & s2' & s2'' & PREF2 & COUNT2 & COUNT2' & GEN2).

    eapply incLocalNamed_count_gen_injective; eauto.
    solve_local_count.
  Qed.

  Lemma lid_bound_before :
    forall s1 s2 x,
      lid_bound s1 x ->
      s1 <<= s2 ->
      lid_bound s2 x.
  Proof.
    intros s1 s2 x BOUND LT.
    unfold lid_bound, state_bound in *.
    destruct BOUND as (prefix & s1' & s2' & PREF & LT' & INC).
    do 3 eexists.
    repeat split.
    all: eauto.
    solve_local_count.
  Qed.

  Lemma lid_bound_count :
    forall s1 s2 pref,
      is_correct_prefix pref ->
      (local_count s2 < local_count s1)%nat ->
      lid_bound s1 (Name (pref @@ string_of_nat (local_count s2))).
  Proof.
    intros s1 s2 pref.
    unfold lid_bound, state_bound in *.
    do 3 eexists.
    repeat split; eauto.
  Qed.

  Lemma lid_bound_between_count :
    forall s1 s2 s pref,
      is_correct_prefix pref ->
      (local_count s1 <= local_count s)%nat ->
      (local_count s < local_count s2)%nat ->
      lid_bound_between s1 s2 (Name (pref @@ string_of_nat (local_count s))).
  Proof.
    intros s1 s2 s pref PREF LE LT.
    unfold lid_bound, state_bound in *.
    do 3 eexists.
    repeat split; eauto.
  Qed.

  Lemma lid_bound_before_bound_between :
    forall s1 s2 id,
      lid_bound s1 id ->
      s1 <<= s2 ->
      exists s0,
        lid_bound_between s0 s2 id.
  Proof.
    intros s1 s2 id BOUND LT.
    destruct BOUND as (prefix & s1' & s2' & PRE & COUNT & GEN).
    exists s1'.
    do 3 eexists.
    repeat split; eauto.
    solve_local_count.
  Qed.
End LidBound.

Ltac solve_lid_bound :=
  solve
    [ eauto
    | eapply incLocal_lid_bound; cbn; eauto
    | eapply incLocalNamed_lid_bound; [solve_prefix | cbn; eauto]
    | eapply newLocalVar_lid_bound; [solve_prefix | cbn; eauto]
    | eapply lid_bound_count; [solve_prefix | solve_local_count]
    | eapply lid_bound_before; [solve [eauto] | solve_local_count]
    ].
