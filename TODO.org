
This development reflects author's Coq learning journey and contains a
lot of an inelegant and redundant code. Additionally, it includes some
workarounds for bugs and limitations for older Coq versions (starting
from 8.4).

It is overdue for serious refactoring and cleanup. Amongst other things:

* Refactoring
** Some other cleanup opportunities are marked with "TODO" comments
** Probably "SUM" shoud be avoided in the name =HTSumUnion= not to confuse
  with =ISUmUnion=.
** Rename =Diamond= to =MR=
** Many unused definitions could be removed. (Hint: try =make print-unused=)
** It looks like =Apply_Family= never used directly. Just =Apply_Family'=.
   We probably need just one definition.
** Run =coq-min-imports= on all codebase
** GEP definition in Coq
** Vellvm as sub-module                                              :zoickx:
   Keep in mind that currently it is linked in 2 places, as follows:
   
   #+BEGIN_SRC sh
   rm -f lib/vellvm
   rm -f ml/libvellvm
   ln -s ~/coq/vellvm lib/
   ln -s ~/coq/vellvm/src/ml/libvellvm ml/
   #+END_SRC

   Ideally, we would like to have HELIX compile out of the box, after
   checkout, without making any symlinks.
   
   Also top-level makefile may compile dependencies (Vellvm, interaction trees).
* Harmonization
** =IReduction= constraints:
  =IReduction= have 2 'compat' assumptions. We have =BFixpoint= in
  =SHOperator= instanct and dense body assumption in =IRedution_Mem=.
  This nees to be normalized.
** =RMonoid= vs =Monoid= 
   Whenever we us =Monoid= as pre-condition for rewriting we should use
   =RMnonoid= which is more general.
** =SHOpeator= constraints:
  For =svalue_at_sparse= we need =szero= to be a fixpoint of =dot=
  (with 2 arguments). For =SHOperator_Mem= we need a =Monoid= which is
  a superset of that. 

** Quasi-Ring
   In one of rewrting proofs (=Diamond_f_subst=) I am using an awkward
   pre-condition which consists of two /Monoids/ which are sharing
   the same /identity element/. It turns out that such algebraic
   structure exists, and called [[https://argumatronic.com/posts/2019-06-21-algebra-cheatsheet.html#ring-like-structures][Quazi-ring]]. Instead of carrying over
   multiple assumptions I should define a typeclass for /QuaziRing/
   and pack them into it.

** Monoidal Restriction
   See if =RelUtil.restrict= could be used in =MonoidalRestriction=.
* Proof mechanics
** Review =_arg_proper= vs =_proper= instances
** Proof-irrelevance assumption could be avoided
** FinNatSet proofs automation via [[https://gmalecha.github.io/reflections/2017/speeding-up-proofs-with-computational-reflection][computational reflection]]          :zoickx:
   (for automatic obligations resoluition in SHCL/MSHCOL/DSHCOL/
   equality).
** Tactic =solve_facts= in =DynWinProof= is hacky and slow.
   - Need more precise matching of goals
   - can use eauto instead of matching
   - can use =typeclasses_eauto= to find some instances
* Unfinished
** Automate /DynWin/ rewriting proof                                 :zoickx:
** Automate SPIRAL log reading for sequence of rewrites
   Perhaps using TemplateCoq?
** =maxnum=  implementation                                          :zoickx:
   Currently implemented as C =max= macro. Should be more
   like =fmax= https://en.cppreference.com/w/c/numeric/math/fmax
   LLVM ref: https://llvm.org/docs/LangRef.html#llvm-maxnum-intrinsic
** Non-array global constants. See =potwise_plusD= test and *TODO* comments in =initIRGlobals=
* Ideas
  - See if =coq-equations= package could be used to represent index
    functions and function arguments of =BinOp=, =Pointwise=, etc.

