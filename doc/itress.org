Notes on DSHCOL to LLVM IR Compiler proofs using =itrees=

These notes describe the undergoing work to prove correct the compiler from
DSHCOL to LLVM IR with respect to Vellvm's semantics.

* An itree-based semantics for DSHCOL 

  We want to prove the compiler correct through a bisimulation expressed in term of
  equivalence of itrees in the style of the POPL paper about them.
  We hence start by giving an itree-based semantics to DSHCOL.
  This semantics, defined in [[../coq/DSigmaHCOL/DSigmaHCOLITree.v][DSigmaHCOLITree]], breaks down in the two usual steps when working with itrees.

** Denotation

  First, ~denoteDSHOperator~ denotes DSHCOL operators in terms of itrees by structural induction.

  The resulting trees may emit events among the following interface:
  - Memory operations (read/write/alloc/free)
  - Dynamic fails (expected to be guaranteed to not be emitted by the programs generated by Helix)
  - Static fails  (expected to be trivially discharged by a type checker)
  
  Note that we chose not to reflect the manipulation of the ~evalContext~ in the tree.

** Interpretation

   We interpret the memory events into the state monad over DSHCOL's notion of memory.
   This interpretation is defined by ~Mem_handler~ and lifted to trees the usual way in ~interp_Mem~.

** Equivalence between both semantics
   
   We have now defined a semantics of DSHCOL as the interpretation of the denotation of its operators.
   Since the compiler to LLVM will be proved with respect to this semantics, but that the upper layers
   are proved with respect to the evaluation function, we need do establish a formal link between both.
   Essentially, this itree-based semantics act as a new intermediate representation, that happens to have
   the same syntax as the previous one :)
   
   To do so, we prove the two following lemmas:
   - ~Denote_Eval_Equiv_Succeeds~: if the evaluation succeeds in returning a memory ~mem~, then the denotation
     is equivalent up-to-tau to the pure computation returning ~mem~
   - ~Denote_Eval_Equiv_Fails~: if the evaluation fails, then the denotation is equivalent to triggering
     either a dynamic failure or a static one.
     Note that this disjunction in the equivalence reflects the fact that we distinguish the two types of
     failure in the denotation but not the evaluation.

   The language being structurally relatively big, the proof takes a bit of work but is overall pleasant to
   conduct.
   An interesting technical point is in the establishment of the equivalence between the looping semantics
   of the evaluation function and the ~iter~ construct on the denotational side that requires a non-trivial
   generalization.

* TODO Initialization phase
  We start with empty states (empty mememory and environments).
  The intialization consists of only initializing global variables.

* TODO Proof of correction
** TODO Statement

** TODO Core Bisimulation
*** TODO Bisimulation relation
    We have multiple bisimulation relation for different stages:
**** Initialization step
     During this step we only enforce memory relation
     during initizalization loop invariant. The relation
     is ~Type_R_memory~.
**** Operator evaluation step     
     The relation is ~Type_R_partial~ which includes memory invariant,
     but does not deal with return value or next block pointer.
**** Final result
     Even though currently is the same type as ~Type_R_partial~ the
      implementation ~bisim_final~ is a relation bewteen the final
      states of evaluation and execution of DHCOL program. At this
      stage we do not care about memory or environemnts, and just
      compare return value of [main] function in LLVM with evaulation
      results of DSHCOL.
*** TODO Bisimulation

* The plan
  [[./2020-01-10 15.32.52.jpg]]
  
